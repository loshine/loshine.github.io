{"posts":[{"title":"使用Jekyll在Github-Pages上搭建个人博客","text":"我的个人博客也在Github-Pages上搭建起来了，其中各个步骤参照了《“授人以渔”的教你搭建个人独立博客》——Azure Yu、《Using Jekyll with Pages》。鄙人于此也作一下使用Jekyll在Github-Pages上搭建个人博客的总结，也可以给其他后来者做一些参考。 本文默认读者已经拥有了Github的帐号，并且对Git的使用较为熟练。如果对Git以及Github不是很了解，可以参考《版本控制入门 – 搬进 Github》。 在这个过程中可能需要使用到少许的Ruby知识，如果您需要学习，可以看这里 开始新建一个仓库 如果没有Github帐号，首先注册一个。 接下来新建一个仓库 注：Repository name(仓库名)必须是 yourusername.github.io 比如我的用户名是loshine，那么我的这个仓库名就是loshine.github.io clone到本地使用Github客户端或者Git命令行工具将这个项目clone到本地。 上传页面之后，新建一个index.html文件，push到对应的master分支（推荐官网教程）。等一段时间之后（可以听首歌），网站生效，访问yourusername.github.io，就能看见完整的网页了。 建造 搭建本地环境由于我们使用Jekell来将markdown文件生成博客文章，所以我们需要搭建本地的Jekyll环境。 Ruby - Mac已经自带了Ruby，所以无需再次安装。如果是其它系统且没有安装Ruby，请安装Ruby环境。 Bundler - 打开终端输入gem install bundler以安装。 github-pages - 打开终端输入gem install github-pages以安装。 Jekyll - 打开终端输入gem install jekyll以安装。 注: 如果你在墙内则可能会出现无法安装的问题，可以通过将Gem源更换为淘宝镜像源解决。 Jekyll的使用 在我们之前创建的仓库下新建一个文件，命名为Gemfile，并写入gem 'github-pages'。 在仓库目录下打开命令行工具，输入bundle install。 在命令行工具中输入bundle exec jekyll serve，按提示打开地址，就可以在本地进行查看和调试网站了。 Jekyll目录解析123456789101112131415161718|—— _config.yml|—— _includes |—— footer.html |—— header.html|—— _layouts |—— default.html |—— post.html|—— _posts |—— 2015-04-09-welcome-to-jekyll.md |—— 2015-08-17-使用Jekyll在Github-Pages上搭建个人博客.md|—— _site|—— css |—— *.css|—— script |—— *.js|—— Gemfile|—— Gemfile.lock|—— index.html 接下来按顺序介绍一下以上文件目录树的每一个文件夹以及文件的作用。 _config.yml 配置文件，你可以在里面配置你博客会用到的常量，比如博客名，邮件 _includes 文章各个部分的html文件，可以在布局中包含这些文件 _layouts 存放模板。就是你网页的布局，主页布局，文章布局。当然不是指CSS那样的布局，是指，你包含哪些基本的内容到页面上。包含的内容就是includes里面的文件。 _posts 存放博客文章 CNAME 域名地址 css 存放博客所用css script 存放博客所用JavaScript index.html 博客主页写博客 博客文章都是用markdown格式书写，命名格式为时间加标题，形如：2015-08-17-使用Jekyll在Github-Pages上搭建个人博客.md 文章需要在开头位置加入一段特殊的文字，其中定义了使用到的样式、文章标题、时间、分类。 123456---layout: posttitle: &quot;Welcome to Jekyll!&quot;date: 2014-01-27 21:57:11categories: Blog--- 完成了以上的步骤，就可以开始撰写博客了。写完之后记得把它放入_post文件夹中，并同步到Github上哦。 装修使用模板之前在[Jekyll目录解析](#jekyll dictionary)中我们大致了解了各个目录的结构。如果您是一名资深的前端工程师，那么就可以直接开始编写自己喜欢的样式的博客了。如果您对于前端并不是那么擅长，那么您可以直接在Jekyll 主题中选择自己喜欢的主题并放入到自己的项目中去。 以我的博客为例，我选择了Pithy主题，将其下载了下来，然后放入了自己的项目中，覆盖已有的文件，然后在终端中输入bundle exec jekyll serve运行jekyll服务器，打开http://localhost:4000就可以查看到效果了。 自定义样式如果您不是一名资深的前端工程师但是还是想要自己定义自己博客的样式。那么我推荐您Run Noob、w3cschool这两个地方学习前端知识。之后您就可以根据自己的需求装点自己的博客了。 定制使用独立域名 新建一个文件，命名为CNAME，然后在里面写入你需要绑定的独立域名就可以了。 在你的域名服务商处添加解析地址。 完成以上步骤你就可以使用自己的独立域名了。 添加评论功能多说多说评论对国内的社交帐号支持不错，自定义性也很强，是一个不错的选择。 登录多说，创建一个项目，拷贝你的通用代码。 在_include文件夹里新建一个comment.html文件，将通用代码粘贴进去。 修改通用代码中需要配置的地方 12&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;请将此处替换成文章在你的站点中的ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt; 修改为 12&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;{{ page.id }}&quot; data-title=&quot;{{ page.title }}&quot; data-url=&quot;your web site{{ page.url }}&quot;&gt;&lt;/div&gt; 注意：your web site需替换为您的域名地址。 在_layout中的post.html中的底部加入【【% include comment.html %】】(此处需将【】换成{}) 在多说的控制台里你可以设置很多自定义项，如：评论审核、评论显示方式、关键词过滤、主题、自定义CSS等 DisqusDisqus支持使用Disqus、Facebook、Twitter以及Google帐号登录，如果你的博客不是主要面向国内普通用户的话，可以考虑使用Disqus。 注册Disqus 右上角设置项中选择Add Disqus To Site，按步骤走，最后复制生成的Universal Code 其它部分类似如上的集成多说操作，但不需要自己修改代码了 Disqus也有控制台可以对评论进行操作 注意：Disqus在国内的访问速度可能比较慢，可能需要慎重考虑使用。 参考 《“授人以渔”的教你搭建个人独立博客》——Azure Yu 官方文档","link":"/2015/08/17/build-personal-blog-in-github-pages-with-jekyll/"},{"title":"Java中的单例设计模式","text":"单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 特点单例模式有以下特点： 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这一实例 实现饿汉式饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。 123456789101112public class Singleton { // 饿汉式，开始就建立一个对象 private static final Singleton single = new Singleton(); // 将构造函数私有，禁止在其它类中创建对象 private Singleton() {} public static Singleton getInstance() { return single; }} 懒汉式懒汉式则是在调用获取实例对象的方法时检查，若没有对象则创建对象，如果单例对象已经存在则不创建对象直接返回已存在的对象。 123456789101112131415public class Singleton { // 懒汉式，刚开始不创建对象 private static Singleton single=null; // 将构造函数私有，禁止在其它类中创建对象 private Singleton() {} // 静态工厂方法 public static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; }} 这种懒汉式实现是非线程安全的，并发环境下很可能出现多个Singleton实例。若要保证线程安全，我们可以使用如下几种方式 同步getInstance()方法 123456public static synchronized Singleton getInstance() { if (single == null) { single = new Singleton(); } return single;} 代码块加锁和双重检查 12345678910public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton;} 静态内部类 123456789101112131415public class Singleton { // 用于封装单例实例的内部类 private static class LazyHolder { private static final Singleton INSTANCE = new Singleton(); } // 私有构造 private Singleton() {} // 获取单例实例的方法 public static final Singleton getInstance() { return LazyHolder.INSTANCE; } } 其中第三种实现方式最好，避免了加锁的效率问题。但实际开发中饿汉式使用较多。","link":"/2015/08/18/singleton-in-java/"},{"title":"Android Studio常用快捷键","text":"之前直接把 Android Studio 的 keymap 改为了 Eclipse 模式，但毕竟这样不利于 Android Studio 的学习，所以这里也记录一下 Android Studio 的快捷键，便于以后查看。 快捷键 Action Mac OSX Win/Linux 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Shift + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Cmd + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 编译项目 Cmd + F9 Ctrl + F9 运行项目 Ctrl + R Ctrl + R 代码提示 Option + Space Alt + Space (PS: 以上快捷键没有在 win 平台尝试确认，如有错误可以在评论中反馈)","link":"/2015/08/20/android-studio-keymap/"},{"title":"Android Design Support Library","text":"Google 在2015的 IO 大会上，给我们带来了更加详细的 Material Design 设计规范，同时，也给我们带来了全新的 Android Design Support Library，在这个 support 库里面，Google 给我们提供了更加规范的 Material design 设计风格的控件。本文将介绍MD设计风格的兼容库以及它们的用法，也是对自己的学习做一个记录。 使用要使用非常简单，在Gradle中添加如下语句即可 1compile 'com.android.support:design:23.0.0' 组件SnackbarSnackbar 提供了一个介于 Toast 和 AlertDialog 之间轻量级控件，它可以很方便的提供消息的提示和动作反馈。其使用方式与Toast基本相同。 12345678910Snackbar.make(view, &quot;Snackbar comes out&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;Action&quot;, new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText( MainActivity.this, &quot;Toast comes out&quot;, Toast.LENGTH_SHORT).show(); } }).show(); 此处注意传入的第一个 view 是 Snackbar 显示的基准元素，Snackbar 会显示在该 view 的底部位置。Action 可以传入多个，每一个都可以配置点击事件。 显示效果： 官网API：Snackbar API TextInputLayout通常，单独的 EditText 会在用户输入第一个字母之后隐藏hint提示信息，但是现在你可以使用 TextInputLayout 来将 EditText 包裹起来，提示信息会变成一个显示在 EditText 之上的 floating label，这样用户就始终知道他们现在输入的是什么。同时，如果给 EditText 增加监听，还可以给它增加更多的 floating label。 使用方法： 12345678910&lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/til_pwd&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 在代码中监听： 1234567891011121314151617181920212223TextInputLayout textInputLayout = (TextInputLayout) findViewById(R.id.til_pwd);EditText editText = textInputLayout.getEditText();textInputLayout.setHint(&quot;Password&quot;);editText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { if (s.length() &gt; 4) { textInputLayout.setError(&quot;Password error&quot;); textInputLayout.setErrorEnabled(true); } else { textInputLayout.setErrorEnabled(false); } } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { } @Override public void afterTextChanged(Editable s) { }}); 注意：TextInputLayout 的颜色来自 style 中的 colorAccent 的颜色： 1&lt;item name=&quot;colorAccent&quot;&gt;#1743b7&lt;/item&gt; 显示效果： 官网API：TextInputLayout API Floating Action ButtonFloatingActionButton 是一个浮动显示的圆形按钮，Design library 中的 FloatingActionButton 实现了一个默认颜色为主题中 colorAccent 的悬浮操作按钮，like this： FloatingActionButton 的使用非常简单，一般将其放入 CoordinatorLayout 中。 1234567&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:src=&quot;@drawable/ic_done&quot;/&gt; 通过指定layout_gravity就可以指定它的位置。 同样，你可以通过指定anchor，即显示位置的锚点： 12345678&lt;android.support.design.widget.FloatingActionButton android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; app:layout_anchor=&quot;@id/app_bar&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; android:src=&quot;@android:drawable/ic_done&quot; android:layout_margin=&quot;15dp&quot; android:clickable=&quot;true&quot;/&gt; 除了一般大小的悬浮操作按钮，它还支持 mini size（fabSize=&quot;mini&quot;）。FloatingActionButton 继承自 ImageView，你可以使用android:src或者 ImageView 的任意方法，比如setImageDrawable()来设置 FloatingActionButton 里面的图标。 官网API：Floating Action Button TabLayoutTabLayout既实现了固定的选项卡 - view的宽度平均分配，也实现了可滚动的选项卡 - view宽度不固定同时可以横向滚动。选项卡可以在程序中动态添加： 1234TabLayout tabLayout = (TabLayout) findViewById(R.id.tabs);tabLayout.addTab(tabLayout.newTab().setText(&quot;tab1&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab2&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab3&quot;)); 通常 TabLayout 都会和 ViewPager 配合起来使用： 12345mViewPager = (ViewPager) findViewById(R.id.viewpager);// 设置 ViewPager 的数据等setupViewPager();TabLayout tabLayout = (TabLayout) findViewById(R.id.tabs);tabLayout.setupWithViewPager(mViewPager); 显示效果： 官网API：TabLayout API NavigationViewNavigationView 主要用于实现滑动显示的导航抽屉，这在 Material Design 中是十分重要的。使用 NavigationView，我们可以这样写导航抽屉了： 1234567891011121314151617181920&lt;android.support.v4.widget.DrawerLayout android:id=&quot;@+id/dl_main_drawer&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;!-- 你的内容布局--&gt; &lt;include layout=&quot;@layout/navigation_content&quot;/&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nv_main_navigation&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/navigation_header&quot; app:menu=&quot;@menu/drawer_view&quot;/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 其中最重要的就是这两个属性：app:headerLayout和app:menu 通过这两个属性，我们可以非常方便的指定导航界面的头布局和菜单布局： 其中最上面的布局就是app:headerLayout所指定的头布局： 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;?attr/colorPrimaryDark&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;16dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt; &lt;ImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;16dp&quot; android:background=&quot;@drawable/ic_user&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:gravity=&quot;center&quot; android:text=&quot;XuYisheng&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Body1&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/LinearLayout&gt; 而下面的菜单布局，我们可以直接通过 menu 内容自动生成，而不需要我们来指定布局： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/nav_home&quot; android:icon=&quot;@drawable/ic_dashboard&quot; android:title=&quot;CC Talk&quot;/&gt; &lt;item android:id=&quot;@+id/nav_messages&quot; android:icon=&quot;@drawable/ic_event&quot; android:title=&quot;HJ Class&quot;/&gt; &lt;item android:id=&quot;@+id/nav_friends&quot; android:icon=&quot;@drawable/ic_headset&quot; android:title=&quot;Words&quot;/&gt; &lt;item android:id=&quot;@+id/nav_discussion&quot; android:icon=&quot;@drawable/ic_forum&quot; android:title=&quot;Big HJ&quot;/&gt; &lt;/group&gt; &lt;item android:title=&quot;Version&quot;&gt; &lt;menu&gt; &lt;item android:icon=&quot;@drawable/ic_dashboard&quot; android:title=&quot;Android&quot;/&gt; &lt;item android:icon=&quot;@drawable/ic_dashboard&quot; android:title=&quot;iOS&quot;/&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 你可以通过设置一个OnNavigationItemSelectedListener，使用其setNavigationItemSelectedListener()来获得元素被选中的回调事件。它可以让你处理选择事件，改变复选框状态，加载新内容，关闭导航菜单，以及其他任何你想做的操作。例如这样： 123456789101112private void setupDrawerContent(NavigationView navigationView) { navigationView.setNavigationItemSelectedListener( new NavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(MenuItem menuItem) { menuItem.setChecked(true); mDrawerLayout.closeDrawers(); return true; } } });} 官网API：NavigationView API AppBarLayoutAppBarLayout 是一个容器，会把所有放在里面的组件一起作为一个 AppBar。 这里就是把 Toolbar 和 TabLayout 放到了 AppBarLayout 中，让他们当做一个整体作为 AppBar。 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 官网API：AppBarLayout API CoordinatorLayoutCoordinatorLayout 是这次新添加的一个增强型的 FrameLayout。在 CoordinatorLayout 中，我们可以在 FrameLayout 的基础上完成很多新的操作。 Floating ViewMaterial Design 的一个新的特性就是增加了很多可悬浮的 View，像我们前面说的 Floating Action Button。我们可以把 FAB 放在任何地方，只需要通过： 1android:layout_gravity=&quot;end|bottom&quot; 来指定显示的位置。同时，它还提供了layout_anchor来供你设置显示坐标的锚点： 1app:layout_anchor=&quot;@id/appbar&quot; 创建滚动CoordinatorLayout 可以说是这次 support library 更新的重中之重。它从另一层面去控制子 view 之间触摸事件的布局，Design Library 中的很多控件都利用了它。 一个很好的例子就是当你将 FloatingActionButton 作为一个子 View 添加进 CoordinatorLayout 并且将 CoordinatorLayout 传递给Snackbar.make()，在3.0及其以上的设备上，Snackbar 不会显示在悬浮按钮的上面，而是 FloatingActionButton 利用 CoordinatorLayout 提供的回调方法，在 Snackbar 以动画效果进入的时候自动向上移动让出位置，并且在 Snackbar 动画地消失的时候回到原来的位置，不需要额外的代码。 官方的例子很好的说明了这一点： 123456789101112131415161718192021222324&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;! -- Your Scrollable View --&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar ... app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt; &lt;android.support.design.widget.TabLayout ... app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 其中，一个可以滚动的组件，例如 RecyclerView、ListView（注意：目前貌似只支持RecyclerView、ListView，如果你用一个ScrollView，是没有效果的）。如果： 给这个可滚动组件设置了layout_behavior 给另一个控件设置了layout_scrollFlags 那么，当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的 view 都需要设置这个 flag，没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个 flag 让任意向下的滚动都会导致该view变为可见。 enterAlwaysCollapsed: 当你的视图已经设置 minHeight 属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 向上滚动时收缩 View。 需要注意的是，后面两种模式基本只有在 CollapsingToolbarLayout 才有用，而前面两种模式基本是需要一起使用的，也就是说，这些 flag 的使用场景，基本已经固定了。 例如我们前面例子中的，也就是这种模式： 1app:layout_scrollFlags=&quot;scroll|enterAlways&quot; PS：所有使用 scroll flag 的 view 都必须定义在没有使用 scroll flag 的 view 的前面，这样才能确保所有的 view 从顶部退出，留下固定的元素。 官网API：CoordinatorLayout CollapsingToolbarLayoutCollapsingToolbarLayout 提供了一个可以折叠的 Toolbar，这也是 Google+、photos 中的效果。Google 把它做成了一个标准控件，更加方便使用。 这里先看一个例子： 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/detail_backdrop_height&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsing_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginEnd=&quot;64dp&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:id=&quot;@+id/backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/ic_banner&quot; app:layout_collapseMode=&quot;parallax&quot;/&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 我们在 CollapsingToolbarLayout 中放置了一个 ImageView 和一个 Toolbar。并把这个 CollapsingToolbarLayout 放到 AppBarLayout 中作为一个整体。在 CollapsingToolbarLayout 中，我们分别设置了 ImageView 和一个 Toolbar 的layout_collapseMode。 这里使用了 CollapsingToolbarLayout 的app:layout_collapseMode=&quot;pin&quot;来确保 Toolbar 在 view 折叠的时候仍然被固定在屏幕的顶部。当你让 CollapsingToolbarLayout 和 Toolbar 在一起使用的时候，title 会在展开的时候自动变得大些，而在折叠的时候让字体过渡到默认值。必须注意，在这种情况下你必须在 CollapsingToolbarLayout 上调用setTitle()，而不是在 Toolbar 上。 除了固定住 view，你还可以使用app:layout_collapseMode=&quot;parallax&quot;（以及使用app:layout_collapseParallaxMultiplier=&quot;0.7&quot;来设置视差因子）来实现视差滚动效果（比如 CollapsingToolbarLayout 里面的一个 ImageView），这中情况和 CollapsingToolbarLayout 的app:contentScrim=&quot;?attr/colorPrimary&quot;属性一起配合更完美。 在这个例子中，我们同样设置了： 1app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; 来接收一个： 1app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; 这样才能产生滚动效果，而通过layout_collapseMode，我们就设置了滚动时内容的变化效果。 CoordinatorLayout与自定义view有一件事情必须注意，那就是 CoordinatorLayout 并不知道 FloatingActionButton 或者 AppBarLayout 的内部工作原理，它只是以Coordinator.Behavior的形式提供了额外的 API，该 API 可以使子 View 更好的控制触摸事件与手势以及声明它们之间的依赖，并通过onDependentViewChanged()接收回调。 可以使用CoordinatorLayout.DefaultBehavior(你的View.Behavior.class)注解或者在布局中使用app:layout_behavior=&quot;com.example.app.你的View$Behavior&quot;属性来定义view的默认行为。framework让任意view和CoordinatorLayout结合在一起成为了可能。 官方API：CollapsingToolbarLayout 总结研究了一整天的 Android Design Support Library，感觉还是非常强大的。虽然自定义性不是很强，但已经给开发者提供了很简单方便的 Material Design 的官方实现，也不用集成很多的第三方库了，还是很不错的，推荐大家在自己的项目中使用。 参考Thanks to 《Android Design Support Library使用详解》","link":"/2015/08/22/android-design-support-library/"},{"title":"Java中的模板方法模式","text":"准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。模版方法模式是基于继承的代码复用的基本技术。 结构模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 示例代码抽象模板角色类，abstractMethod()、doHookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 1234567891011121314151617181920212223242526272829public abstract class AbstractTemplate { /** * 模板方法 */ public void templateMethod(){ // 调用基本方法 abstractMethod(); doHookMethod(); concreteMethod(); } /** * 抽象方法，子类必须实现的方法 */ protected abstract void abstractMethod(); /** * 钩子方法，子类可选择是否实现。注意钩子方法一般以 do 开头 */ protected void doHookMethod(){} /** * 具体方法，由父类实现，子类无法 override */ private final void concreteMethod(){ // 业务相关的代码 }} 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而doHookMethod()方法是可选择实现的逻辑，不是必须实现的。 1234567891011121314public class ConcreteTemplate extends AbstractTemplate { // 基本方法的实现 @Override public void abstractMethod() { // 业务相关的代码 } // 重写父类的方法 @Override public void hookMethod() { // 业务相关的代码 }} 模板方法模式的关键：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照责任的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 在Servlet中的应用使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。HttpService类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。下面是service()方法的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp); } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req,resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req,resp); } else { // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); }} 当然，这个service()方法也可以被子类置换掉。 下面给出一个简单的 Servlet 例子： TestServlet 类是 HttpServlet 类的子类，并且置换掉了父类的两个方法：doGet()和doPost()： 12345678910111213141516public class TestServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;using the GET method&quot;); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;using the POST method&quot;); } } 从上面的例子可以看出这是一个典型的模板方法模式。 HttpServlet 担任抽象模板角色 模板方法：由service()方法担任。 基本方法：由doPost()、doGet()等方法担任。 TestServlet 担任具体模板角色 TestServlet 置换掉了父类 HttpServlet 中七个基本方法中的其中两个，分别是doGet()和doPost()。","link":"/2015/08/25/template-method-pattern-in-java/"},{"title":"Android网络通信框架Volley","text":"之前我们在Android应用中的网络通信，一般都是使用AsyncTaskLoader，HttpURLConnection，AsyncTask，HTTPClient（Apache）等。但在 Google I/O 2013上，Google 发布了一个新的网络通信框架——Volley。Volley 适合数据量不大但通信十分频繁的场景，它使得Http通信操作相比以前更加简单、快捷、健壮。 Why之前从网络下载图片可能要这样： 在ListAdapter#getView()里开始图像的读取 通过 AsyncTask 等机制使用 HttpURLConnection 从服务器去的图片资源 在AsyncTask#onPostExecute()里设置相应 ImageView 的属性 再有，屏幕旋转的时候，有时候会导致再次从网络取得数据。为了防止不必要的网络访问，可能我们要自己实现 cache。 还有 ListView 滚动过快时，可能会导致有些网络请求返回数据时早已不需要显示了。 这些问题使用 Volley 都可以很简单地解决。 Volley 提供了如下的便捷功能： JSON，图像的异步下载 网络请求序列 网络请求优先级处理 缓存 多级别取消请求 和 Activity 生命周期的联动 人生苦短，快用 Volley！ How集成三种集成方法，其中后两种都是非官方渠道： 编译源码导入项目 从 Git 库 clone 最新版 1git clone https://android.googlesource.com/platform/frameworks/volley 编译为 jar 包 导入项目 Gradle构建（非官方渠道，推荐） 1compile 'com.mcxiaoke.volley:library:1.0.18' Maven构建（非官方渠道） 12345&lt;dependency&gt; &lt;groupId&gt;com.mcxiaoke.volley&lt;/groupId&gt; &lt;artifactId&gt;library&lt;/artifactId&gt; &lt;version&gt;{latest-version}&lt;/version&gt;&lt;/dependency&gt; 使用具体使用流程如下： 在 Activity 中构造一个（一个就够了）RequestQueue 请求序列对象 创建一个 Request 对象（子类实现） 添加到序列 开始序列 在这四步中，我们着重要关注的是第二步，Request 是一个抽象类，我们所以我们要用到它的子类实现，Volley中已经实现了以下几个子类： ClearCacheRequest ImageRequest JSONRequest StringRequest 下面我们就对这几个子类进行介绍以及给出示例 ClearCacheRequest虚构的请求，用于清空已有的缓存文件。 ClearCacheRequest的优先级很高，为Priority.IMMEDIATE，所以在被添加到 RequestQueue 后能很快执行。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ImageRequest待完成 JSONRequestJSONRequest 也是一个抽象类，所以我们在使用时要用到它的两个实现子类——JsonObjectRequest 和 JsonArrayRequest。 JsonObjectRequest 允许上传 JsonObject 数据，并根据请求返回数据。但 JsonArrayRequest 的实现过于简单，不能携带上传 json 数据，只能使用 GET 方式请求网络。 StringRequestStringRequest 是最为常用也是最灵活的 Request 实现。一个简单的 Get 请求获取百度首页的例子： 1234567891011121314151617181920212223242526272829303132333435363738public class StringRequestActivity extends AppCompatActivity { /** * Volley 请求队列对象 */ private RequestQueue mRequestQueue; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_string_request); // 构造请求队列 mRequestQueue = Volley.newRequestQueue(context); StringRequest request = new StringRequest(&quot;http://www.baidu.com&quot;, new Response.Listener&lt;String&gt;() { @Override public void onResponse(String response) { JSONObject jsonObject = JSON.parseObject(response, JSONObject.class); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { Log.i(&quot;net error&quot;, error.getLocalizedMessage()); } }); mRequestQueue.add(request); } @Override protected void onStop() { super.onStop(); // 退出时取消所有网络请求 mRequestQueue.cancelAll(this); }} 自定义Request一个简单的使用 Pull 解析的 XMLRequest 123456789101112131415161718192021222324252627282930313233343536public class XMLRequest extends Request&lt;XmlPullParser&gt; { private final Listener&lt;XmlPullParser&gt; mListener; public XMLRequest(int method, String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) { super(method, url, errorListener); mListener = listener; } public XMLRequest(String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) { this(Method.GET, url, listener, errorListener); } @Override protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) { try { String xmlString = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlString)); return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response)); } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); } catch (XmlPullParserException e) { return Response.error(new ParseError(e)); } } @Override protected void deliverResponse(XmlPullParser response) { mListener.onResponse(response); } } 在parseNetworkResponse()方法中将服务器响应的数据解析成一个字符串，然后设置到XmlPullParser对象中。在deliverResponse()方法中则是将XmlPullParser对象进行回调。 与生命周期的联动当 Activity 里面启动了网络请求，如果这个网络请求还没返回结果的时候，Activity 就被结束了。此时如果继续使用其中的 Context 等会消耗没有必要的系统资源，而且还有可能会导致程序 crash。 所以在使用 Volley 时，我们应该在 Activity 停止的时候，同时取消所有或部分未完成的网络请求。Volley 里所有的请求结果会返回给主进程，如果在主进程里取消了某些请求，则这些请求将不会被返回给主线程。Volley 支持多种 Request 取消方式。 可以针对某些个 request 做取消操作 123456@Overridepublic void onStop() { for (Request &lt;?&gt; req : mRequestQueue) { req.cancel(); }} 取消这个队列里的所有请求 12345@Overrideprotected void onStop() { super.onStop(); mRequestQueue.cancelAll(this);} 可以根据 RequestFilter 或者 Tag 来终止某些请求 123456789@Override protected void onStop() { super.onStop(); // 根据 RequestFilter mRequestQueue.cancelAll(new RequestFilter() {}); // 根据 Tag mRequestQueue.cancelAll(new Object());}","link":"/2015/08/27/volley/"},{"title":"打磨真正属于自己的输入法-RIME","text":"很久之前就发现了 RIME 这个输入法，但因为在 windows 下的种种不便，把玩了一段时间后终于还是将之打入箱底。近期由于换上了 mac 作为主力开发机，于是又将其从箱底翻出，仔细把玩打磨一段时间之后已经十分跟手了，于是乎在这里记录一下打磨过程。 简介RIME，全称是中州韵输入法引擎，是由佛振先生开发的跨平台开源输入法。 它在不同平台上有不同的名字： Windows：小狼毫 Weasel Mac OS X： 鼠须管 Squirrel Linux：ibus-rime or fcitx-rime 其内置的输入方案包括 朙月拼音 朙月拼音 语句流 朙月拼音 简化字模式 朙月拼音 臺灣正體模式 地球拼音 dì qiú pīn yīn 注音 注音 臺灣正體模式 粵拼 倉頡五代 倉頡 快打模式 速成 五笔86 五笔拼音混合輸入 自然碼雙拼 微軟雙拼 智能ABC雙拼 小鶴雙拼 吳語上海話（新派） 吳語上海話（老派） 中古漢語三拼 中古漢語全拼 X-SAMPA 國際音標 emoji表情 再由于其强大的可定制性，也有许多爱好者为其制作了如下输入方案 英文 日语 山人全息码 …… 它也集成了许多好看的主题，当然你也可以自定义自己喜欢的配色主题。 安装前往下载地址选择对应的版本下载，Mac用户选择鼠须管 Squirrel即可。 下载完成之后，解压zip压缩包，然后打开Squirrel-versioncode.pkg按步骤安装即可。 使用 Mac用户在输入源中添加鼠须管 按⌘ + Space切换输入法到鼠须管 按下Ctrl + `，依次选择 2、4 切换到简体输入 Enjoy it！ 自定义点击右上角输入法按钮，选择用户设定，可以看到所有鼠须管的配置文件。鼠须管的配置文件都是yaml格式的，我们如果想要自定义，可以新建一个*.custom.yaml对其进行修改，这样可以防止更新程序的时候修改内容被覆盖，也方便同步。 输入方案新建一个default.custom.yaml文件，将如下内容复制进去，然后根据自己的需求注释或者去掉注释即可。在完成之后，不要忘记重新部署一下，之后就可以使用Ctrl + `切换输入方案了。 12345678910111213141516171819202122232425patch: schema_list: - schema: luna_pinyin # 朙月拼音 - schema: luna_pinyin_fluency # 朙月拼音 语句流# - schema: luna_pinyin_simp # 朙月拼音 简化字模式# - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn# - schema: bopomofo # 注音# - schema: bopomofo_tw # 注音 臺灣正體模式# - schema: jyutping # 粵拼# - schema: cangjie5 # 倉頡五代# - schema: cangjie5_express # 倉頡 快打模式# - schema: quick5 # 速成# - schema: wubi86 # 五笔86 - schema: wubi_pinyin # 五笔拼音混合輸入# - schema: double_pinyin # 自然碼雙拼# - schema: double_pinyin_mspy # 微軟雙拼# - schema: double_pinyin_abc # 智能ABC雙拼# - schema: double_pinyin_flypy # 小鶴雙拼# - schema: wugniu # 吳語上海話（新派）# - schema: wugniu_lopha # 吳語上海話（老派）# - schema: sampheng # 中古漢語三拼# - schema: zyenpheng # 中古漢語全拼# - schema: ipa_xsampa # X-SAMPA 國際音標 - schema: emoji # emoji表情 外观新建一个squirrel.custom.yaml文件，向其中写入如下内容，然后根据自己的需求修改。 12345678910111213141516171819202122232425# 適用於【鼠鬚管】0.9.13+# 位置：~/Library/Rime/squirrel.custom.yaml# 用法：想要哪項生效，就刪去該行行首的#字符，但注意保留用於縮進的空格patch:# us_keyboard_layout: true # 鍵盤選項：應用美式鍵盤佈局# show_notifications_when: growl_is_running # 狀態通知，默認裝有Growl時顯示，也可設爲全開（always）全關（never）# style/horizontal: true # 候選窗横向顯示# style/inline_preedit: false # 非內嵌編碼行# style/font_face: &quot;儷黑 Pro&quot; # 我喜歡的字體名稱# style/font_point: 21 # 字號# style/corner_radius: 10 # 窗口圓角半徑# style/border_height: 0 # 窗口邊界高度，大於圓角半徑才有效果# style/border_width: 0 # 窗口邊界寬度，大於圓角半徑才有效果# style/color_scheme: luna # 選擇配色方案# 註：預設的配色方案及代碼（指定爲 style/color_scheme ）# 碧水 - aqua# 青天 - azure# 明月 - luna# 墨池 - ink# 孤寺 - lost_temple# 暗堂 - dark_temple# 星際我爭霸 - starcraft# 谷歌 - google 主题如上一部分，只能设置默认的主题。虽然默认的主题也挺不错的，但是我们也可以定制自定义的主题。 还是在squirrel.custom.yaml中，在刚刚加入的内容后面加入如下内容 1234567891011preset_color_schemes/textflow: author: &quot;name &lt;name@gmail.com&gt;&quot; back_color: 0xFFFFFF #背景 border_color: 0xE0B693 #边框 candidate_text_color: 0x000000 #非第一候选项 hilited_back_color: 0xEBECED #拼音串高亮背景 hilited_candidate_back_color: 0xFFFFFF #第一候选项背景 hilited_candidate_text_color: 0xF57C75 #第一候选项 hilited_text_color: 0xFF6666 #拼音串高亮 name: Textflow text_color: 0x000000 #拼音串 然后启用这个主题就可以了 如果你想要更多的配色，可以参照RIME吧：配色方案专帖 生僻字乱码生僻字乱码是因为默认字库中不含生僻字所导致的，解决方案就是为其设置字库齐全的备用字体。 一般的选择是「花园明朝」，下载下来安装好之后，将 外观 这一步中的 1style/font_face: &quot;儷黑 Pro&quot; # 我喜歡的字體名稱 改为 1style/font_face: &quot;PingFang SC,HanaMinA&quot; # 我喜歡的字體名稱 然后重新部署即可 根据程序切换中英文鼠须管 0.9.9 之后开始支持在指定的应用程序中设定输入法的初始状态。 如在 终端 Terminal、iTerm2 编辑器 sublime、atom 启动工具 QuickSilver、Alfred 中我们很少会用到中文，于是我们可能设置鼠须管在这种程序中默认英文输入 如果想要设置应用中输入法的初始状态，我们首先要查看应用的Info.plist文件得到该应用的Bundle Identifier，通常是形如com.apple.Xcode的字符串 例如，要在Xcode中默认英文输入，又要在Alfred中恢复中文输入，可如下设定： 12345# example squirrel.custom.yamlpatch: app_options/com.apple.Xcode: ascii_mode: true app_options/com.alfredapp.Alfred: {} emoji表情以及特殊符号有时候我们会有输入emoji表情的需求，但仅仅只是开启了emoji输入方案的话，我们每次都要切换输入方案才可以输入emoji表情，还是很不方便的。如果可以直接在一种输入方案中加入emoji表情输入就更好了 其实可以做到，你只需要这样 1234567891011121314151617181920# luna_pinyin.custom.yaml## 在【朙月拼音】裏使用Emoji表情## 保存到Rime用戶文件夾後，重新部署生效# ~/.config/ibus/rime (linux)# ~/Library/Rime (macos)# %APPDATA%\\Rime (windows)## 如果目標文件已經包含其他修改內容，只需按照縮進合併 patch: 以下的部分#patch: schema/dependencies: - emoji reverse_lookup: dictionary: emoji enable_completion: false prefix: &quot;`&quot; tips: 〔表情〕 以上我们就完成了emoji表情输入的设置，现在输入一个`加随意一些字母来看看效果吧 但是仅仅表情还不够，我们有时候需要输入形如ⅺ、⑴、☁之类的特殊符号，查看symbols.yaml我们可以发现及其丰富的特殊符号，但是如何才能使用它们呢？ 只需要在我们上面已经添加了emoji表情相关的配置文件末尾再加上如下配置即可 12345678punctuator: import_preset: symbolsrecognizer: import_preset: default patterns: reverse_lookup: &quot;`[a-z]*'?$&quot; punct: &quot;^/([a-z]+|[0-9]0?)$&quot; 大功告成，重新部署之后使用/lm看看吧，更多符号输入方式请查看symbols.yaml 同步做了这么多的个性化设置之后，其实输入法应该已经很符合自己的心意了。但是如果我们更换了一台设备或者需要在其它设备上保持同样的习惯的话怎么办呢？我们使用这么久已经养成了的个人词库可以在其它设备上使用么？ 当然可以！ RIME是支持同步的，但是它的同步方式和市面上主流的输入法不一样，需要我们自己使用同步网盘或者U盘来同步。 推荐国内用户使用坚果云作为同步盘使用，坚果云拥有多平台客户端且在墙内使用情况良好。若肉身在墙外则推荐DropBox 1. 设定同步位置默认情况下，个人词库和配置都将备份到RIME用户文件夹\\sync\\UUID这里。如果使用网盘或者U盘在不同机器、系统之间同步，则需要设定同步的目标文件夹，此时这些文件都会备份到设定好的目录。 直接編輯用戶文件夾下的installation.yaml，添加： 1sync_dir: 'D:\\Dropbox\\RimeSync' 又如 Mac 上添加： 1sync_dir: '/Users/fred/Dropbox/RimeSync' 又如使用 USB 存儲來同步：（真實案例） 1sync_dir: '/Volumes/USBDRIVE/RimeSync' 2. 同步标识默认情况下，RIME会为随机生成每一个UUID作为标识。这个UUID会被用来区分來自不同机器/系统的个人词库和设置。 如果你想要让其更加便于管理，那么你可以设置一个有意义的ID用于区分，直接编辑installation.yaml中如下所示的内容即可 1installation_id: 'loshine-macbook' 注意：此ID不能使用非法字符，建议只用小写字母、数字、横线和下划线 我的成品成品效果演示 几个配置文件 squirrel.custom.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 適用於【鼠鬚管】0.9.13+# 位置：~/Library/Rime/squirrel.custom.yaml# 用法：想要哪項生效，就刪去該行行首的#字符，但注意保留用於縮進的空格patch:# us_keyboard_layout: true # 鍵盤選項：應用美式鍵盤佈局 show_notifications_when: appropriate # 狀態通知，默認裝有Growl時顯示，也可設爲全開（always）全關（never）# style/horizontal: true # 候選窗横向顯示# style/inline_preedit: false # 非內嵌編碼行# style/font_face: &quot;PingFang SC,HanaMinA&quot; # 我喜歡的字體名稱 style/font_point: 18 # 字號 style/corner_radius: 2 # 窗口圓角半徑 style/border_height: 7 # 窗口邊界高度，大於圓角半徑才有效果 style/border_width: 7 # 窗口邊界寬度，大於圓角半徑才有效果 style/color_scheme: luna # 選擇配色方案# 註：預設的配色方案及代碼（指定爲 style/color_scheme ）# 碧水 - aqua# 青天 - azure# 明月 - luna# 墨池 - ink# 孤寺 - lost_temple# 暗堂 - dark_temple# 星際我爭霸 - starcraft# 谷歌 - google preset_color_schemes/textflow: author: &quot;name &lt;name@gmail.com&gt;&quot; back_color: 0xFFFFFF #背景 border_color: 0xE0B693 #边框 candidate_text_color: 0x000000 #非第一候选项 hilited_back_color: 0xEBECED #拼音串高亮背景 hilited_candidate_back_color: 0xFFFFFF #第一候选项背景 hilited_candidate_text_color: 0xF57C75 #第一候选项 hilited_text_color: 0xFF6666 #拼音串高亮 name: Textflow text_color: 0x000000 #拼音串# Xcode app_options/com.apple.Xcode: ascii_mode: true# alfred app_options/com.alfredapp.Alfred: ascii_mode: true# Android Studio app_options/com.google.android.studio: ascii_mode: true# atom app_options/com.github.atom: ascii_mode: true default.custom.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960patch: schema_list: - schema: luna_pinyin # 朙月拼音 - schema: luna_pinyin_fluency # 朙月拼音 语句流# - schema: luna_pinyin_simp # 朙月拼音 简化字模式# - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn# - schema: bopomofo # 注音# - schema: bopomofo_tw # 注音 臺灣正體模式# - schema: jyutping # 粵拼# - schema: cangjie5 # 倉頡五代# - schema: cangjie5_express # 倉頡 快打模式# - schema: quick5 # 速成# - schema: wubi86 # 五笔86 - schema: wubi_pinyin # 五笔拼音混合輸入# - schema: double_pinyin # 自然碼雙拼# - schema: double_pinyin_mspy # 微軟雙拼# - schema: double_pinyin_abc # 智能ABC雙拼# - schema: double_pinyin_flypy # 小鶴雙拼# - schema: wugniu # 吳語上海話（新派）# - schema: wugniu_lopha # 吳語上海話（老派）# - schema: sampheng # 中古漢語三拼# - schema: zyenpheng # 中古漢語全拼# - schema: ipa_xsampa # X-SAMPA 國際音標 - schema: emoji # emoji表情{% endhighlight %}* terra_pinyin.custom.yaml{% highlight yaml %}# luna_pinyin.custom.yaml## 在【地球拼音】裏使用Emoji表情## 保存到Rime用戶文件夾後，重新部署生效# ~/.config/ibus/rime (linux)# ~/Library/Rime (macos)# %APPDATA%\\Rime (windows)## 如果目標文件已經包含其他修改內容，只需按照縮進合併 patch: 以下的部分#patch: schema/dependencies: - emoji# abc_segmentor/extra_tags:# - reverse_lookup reverse_lookup: dictionary: emoji enable_completion: false prefix: &quot;`&quot; tips: 〔表情〕 punctuator: import_preset: symbols recognizer: import_preset: default patterns: reverse_lookup: &quot;`[a-z]*'?$&quot; punct: &quot;^/([a-z]+|[0-9]0?)$&quot; installation.yaml 1234567distribution_code_name: Squirreldistribution_name: &quot;鼠鬚管&quot;distribution_version: 0.9.26.1install_time: &quot;Mon Aug 3 15:24:12 2015&quot;installation_id: &quot;loshine-macbook&quot;rime_version: 1.2.9sync_dir: '/Users/Loshine/我的坚果云/RimeSync'","link":"/2015/09/12/rime/"},{"title":"Kotlin中实现Parcelable","text":"在Android中，如果需要序列化对象可以选择实现 Serializable 或 Parceable。如果是在使用内存的情况下，Parcelable 的效率比 Serializable 高。但 Parcelable 不能被持久化存储，此时还是需要实现 Serializable。 Java实现首先我们看一个普通的 JavaBean 1234567891011121314151617181920212223242526272829303132333435/** * 帖子实体类 * &lt;p/&gt; * Created by Loshine on 15/9/8. */public class PostEntity { /** * 帖子标题 */ private String name; /** * 帖子类别 */ private String category; /** * 帖子链接 */ private String link; /** * 评论数 */ private String comments; /** * 发布者 */ private String announcer; /** * 最新回复时间 */ private String replyTime; /* * 省略 getter setter... */ 其中的代码都是 JavaBean 的属性以及 getter、setter 如果其实现 Parcelable，则是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 帖子实体类 * &lt;p/&gt; * Created by Loshine on 15/9/8. */public class PostEntity implements Parcelable { /** * 帖子标题 */ private String name; /** * 帖子类别 */ private String category; /** * 帖子链接 */ private String link; /** * 评论数 */ private String comments; /** * 发布者 */ private String announcer; /** * 最新回复时间 */ private String replyTime; /* * 省略 getter setter... */ @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(this.name); dest.writeString(this.category); dest.writeString(this.link); dest.writeString(this.comments); dest.writeString(this.announcer); dest.writeString(this.replyTime); } public PostEntity() { } protected PostEntity(Parcel in) { this.name = in.readString(); this.category = in.readString(); this.link = in.readString(); this.comments = in.readString(); this.announcer = in.readString(); this.replyTime = in.readString(); } public static final Parcelable.Creator&lt;PostEntity&gt; CREATOR = new Parcelable.Creator&lt;PostEntity&gt;() { public PostEntity createFromParcel(Parcel source) { return new PostEntity(source); } public PostEntity[] newArray(int size) { return new PostEntity[size]; } }; 在实现Parcelable的时候我们需要重写两个方法 public void writeToParcel(Parcel dest, int flags) public int describeContents() 其中describeContents只需要返回 0 即可 writeToParcel方法中我们把需要序列化的属性使用writeXXX的方式写入 Parcel 。 之后是 CREATOR 对象，这个对象负责从 Parcel 中读取对象，所以我们需要重写其方法来读取对象 123456789101112131415161718protected PostEntity(Parcel in) { this.name = in.readString(); this.category = in.readString(); this.link = in.readString(); this.comments = in.readString(); this.announcer = in.readString(); this.replyTime = in.readString(); } public static final Parcelable.Creator&lt;PostEntity&gt; CREATOR = new Parcelable.Creator&lt;PostEntity&gt;() { public PostEntity createFromParcel(Parcel source) { return new PostEntity(source); } public PostEntity[] newArray(int size) { return new PostEntity[size]; } }; 这一段就是其实现方式，可见主要是将对象从 Parcel 中读取出来。 Kotlin实现看过了冗长的 Java 实现方式，我们来看看kotlin是如何实现的吧。 首先使用插件将其转换为 Kotlin 文件，并修改其中的错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class PostEntity : Parcelable { /** * 帖子标题 */ var name: String? = null /** * 帖子类别 */ var category: String? = null /** * 帖子链接 */ var link: String? = null /** * 评论数 */ var comments: String? = null /** * 发布者 */ var announcer: String? = null /** * 最新回复时间 */ var replyTime: String? = null override fun describeContents(): Int { return 0 } override fun writeToParcel(dest: Parcel, flags: Int) { dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) } constructor() { } protected constructor(`in`: Parcel) { this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() } companion object { val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; { override fun createFromParcel(source: Parcel): PostEntity { return PostEntity(source) } override fun newArray(size: Int): Array&lt;PostEntity?&gt; { return arrayOfNulls(size) } } }} 这就是 Kotlin 实现 Parcelable 的方式了 优化经过插件转化的 kotlin 代码其实使用的还是 java 的方式和 java 的思想，我们可以将其完全转化为 kotlin 的方式并对其优化 首先把其转化为数据类，这样会自动为我们生成 equals()/hashCode() toString() componentN() copy() 我们只需要将其改为这样 12345678910111213141516171819202122232425262728293031323334353637383940414243data class PostEntity(var name: String? = null, /* 帖子标题*/ var category: String? = null, /* 帖子类别 */ var link: String? = null, /* 帖子链接 */ var comments: String? = null, /* 评论数 */ var announcer: String? = null, /* 发布者 */ var replyTime: String? = null /* 最新回复时间 */) : Parcelable { override fun describeContents(): Int { return 0 } override fun writeToParcel(dest: Parcel, flags: Int) { dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) } protected constructor(`in`: Parcel) : this() { this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() } companion object { val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; { override fun createFromParcel(source: Parcel): PostEntity { return PostEntity(source) } override fun newArray(size: Int): Array&lt;PostEntity?&gt; { return arrayOfNulls(size) } } }} 再之后观察发现，所有的 Parcelable 都需要有一个 CREATOR 123456789101112companion object { val CREATOR: Parcelable.Creator&lt;PostEntity&gt; = object : Parcelable.Creator&lt;PostEntity&gt; { override fun createFromParcel(source: Parcel): PostEntity { return PostEntity(source) } override fun newArray(size: Int): Array&lt;PostEntity?&gt; { return arrayOfNulls(size) } }} 此处使用了 Kotlin 的伴生对象，使得调用 CREATOR 类似于 Java 中的静态属性 可以使用 Kotlin 的函数式编程特性抽取 新建文件ParcelableExt.kt 12345public inline fun createParcel&lt;reified T : Parcelable&gt;(crossinline createFromParcel: (Parcel) -&gt; T?): Parcelable.Creator&lt;T&gt; = object : Parcelable.Creator&lt;T&gt; { override fun createFromParcel(source: Parcel): T? = createFromParcel(source) override fun newArray(size: Int): Array&lt;out T?&gt; = arrayOfNulls(size) } 此处使用了 Kotlin 的内联函数，然后我们就可以将 PostEntity 精简为如下 12345678910111213141516171819202122232425262728293031323334data class PostEntity(var name: String? = null, /* 帖子标题*/ var category: String? = null, /* 帖子类别 */ var link: String? = null, /* 帖子链接 */ var comments: String? = null, /* 评论数 */ var announcer: String? = null, /* 发布者 */ var replyTime: String? = null /* 最新回复时间 */) : Parcelable { override fun describeContents(): Int { return 0 } override fun writeToParcel(dest: Parcel, flags: Int) { dest.writeString(this.name) dest.writeString(this.category) dest.writeString(this.link) dest.writeString(this.comments) dest.writeString(this.announcer) dest.writeString(this.replyTime) } protected constructor(`in`: Parcel) : this() { this.name = `in`.readString() this.category = `in`.readString() this.link = `in`.readString() this.comments = `in`.readString() this.announcer = `in`.readString() this.replyTime = `in`.readString() } companion object { val CREATOR = createParcel { PostEntity(it) } }} 总结虽然可以直接将 Java 文件转化为 Kotlin 文件，但这样毕竟没有办法学习到 Kotlin 的精髓 使用一门语言就应该按照这门语言的编码风格以及规范去实现，这样才会让我们的学习更加有效率且养成良好的编码习惯 Kotlin 是一门典型的函数式编程语言，学习它的风格有利于我们了解函数式编程思想 在实现 Parceable 时我们使用了 Kotlin 的几个特性 数据类 二级构造函数 内联函数 查阅官方文档完成的同时我也学会了新的姿势知识，想一想也有点小激动呢","link":"/2015/10/17/implements-parcelable-in-kotlin/"},{"title":"Kotlin中的委托属性","text":"Kotlin 是 Jetbrain 推出的一门运行在 JVM 上的语言，它结合了面向对象以及函数式语言的特性，超甜的语法糖以及来自知名 IDE 大厂 Jetbrain 的出身让它初一面世就广受瞩目，特别是在 Android 开发社区中。它相比起 Java 拥有了许许多多的优秀特性，并且几乎每一个新特性都对应解决了 Java 开发时的痛苦之处，本篇文章主要讲解 Kotlin 中的委托属性这一特性。 委托属性(Delegated Properties)我们先看看官网的定义： 有一些种类的属性，虽然我们可以在每次需要的时候手动实现它们，但是如果能够把他们之实现一次 并放入一个库同时又能够一直使用它们那会更好。例如： 延迟属性（lazy properties）: 数值只在第一次被访问的时候计算。 可控性（observable properties）: 监听器得到关于这个特性变化的通知， 把所有特性储存在一个映射结构中，而不是分开每一条。 为了支持这些(或者其他)例子，Kotlin 采用 委托属性。 简言之就是简化手动实现的属性，将其抽象出一个库。 如何使用定义一个委托Kotlin 中有两种属性：用var修饰的可变属性和由val修饰的只读属性。由val修饰的只读属性使用的委托需要实现ReadOnlyProperty，而var修饰的可变属性则需要实现ReadWriteProperty 在调用被委托的属性的getter和setter时，对应操作会被委托给getValue()以及setValue()。 如实现一个最简单的委托Delegate： 123456789class Delegate { operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { return &quot;$thisRef, thank you for delegating '${property.name}' to me!&quot; } operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { println(&quot;$value has been assigned to '${property.name} in $thisRef.'&quot;) }} 使用定义好的委托属性语法为val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; 123class Example { var p: String by Delegate()} by后面的是委托表达式，我们调用这个对象并使用属性： 1234val e = Example()println(e.p)e.p = &quot;NEW&quot; 打印结果为： 12Example@33a17727, thank you for delegating 'p' to me!NEW has been assigned to 'p' in Example@33a17727. 如上可知，thisRef对应的是拥有该被委托属性的对象实例，property则是属性，value是调用setter时的传入值。 实例讲解lazy 懒加载Kotlin 标准库自带的懒加载委托，在属性第一次被使用时才进行初始化。 函数lazy()接受一个 lambda 然后返回一个可以作为委托Lazy&lt;T&gt; 实例来实现延迟属性: 第一个调用getter执行变量传递到lazy()并记录结果, 后来的getter调用只会返回记录的结果。 123456789val lazyValue: String by lazy { println(&quot;computed!&quot;) &quot;Hello&quot;}fun main(args: Array&lt;String&gt;) { println(lazyValue) println(lazyValue)} 其打印结果： 123computed! # 第一次使用时先初始化Hello # getterHello # 后续都只会调用 getter 懒加载委托在实际编码中应用十分广泛，比如 Android 中我们可以把很多在OnCreate中需要进行的初始化操作使用懒加载委托来实现。 使用委托操作 SharedPreferences本例出自《Kotlin for Android Developer》，使用了when表达式和委托属性巧妙地使得SharedPrefences的读写变得十分简便 123456789101112131415161718192021222324252627282930313233343536class Preference&lt;T&gt;(val context: Context, val name: String, val default: T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun &lt;U&gt; findPreference(name: String, default: U): U = with(prefs) { val res: Any = when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;This type can be saved into Preferences&quot;) } res as U } private fun &lt;U&gt; putPreference(name: String, value: U) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;This type can be saved into Preferences&quot;) }.apply() }} 在代码中我们可以如下使用 12345678class WhateverActivity : Activity() { var aInt: Int by Preference(this, &quot;aInt&quot;, 0) fun whatever() { println(aInt) // 会从 SharedPreference 取这个数据 aInt = 9 // 会将这个数据写入 SharedPreference }} 从此操作SharedPreferences变得如此简单 ~ 简单实现一个 KotterKnifeKotterKnife 是一个 Android 控件依赖注入框架，使用它可以很方便地初始化 Activity、Fragment、View 等的控件。 KotterKnife 的实现原理就是使用了委托属性，下面我就使用委托属性简单实现一个 View 注入功能 实现我们平时是这样初始化 View 的 123456override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val textView = findViewById(R.id.text_view) as TextView} 考虑到通常我们在onCreate方法中将其初始化，我们可以用 lazy 委托，在第一次使用该控件的时候才将其初始化，这样可以减少不必要的内存消耗。 123val mTextView by lazy { findViewById(R.id.text_view) as TextView} 对其抽取简化 1234567@Suppress(&quot;UNCHECKED_CAST&quot;)fun &lt;V : View&gt; Activity.bindView(id: Int): Lazy&lt;V&gt; = lazy { viewFinder(id) as V}private val Activity.viewFinder: Activity.(Int) -&gt; View? get() = { findViewById(it) } 之后我们就可以在 Activity 中这样注入 View 了 1val mTextView by bindView&lt;TextView&gt;(R.id.text_view) 如上实现了类似 KotterKnife 的控件注入功能，当然 KotterKnife 中还有更加强大的可选绑定以及数组绑定，本文中我们就不细说了，有兴趣的读者可以阅读 KotterKnife源码。 小结本文分析了 Kotlin 中的委托属性，并对其实际应用做了示例分析。委托属性是 Kotlin 语言的一个特性，灵活使用可以解决实际编码中的许多问题，减少大量重复代码，而由于其与属性的getter、setter直接绑定所以使用起来也十分灵活方便。 总而言之：这真是极好的。","link":"/2016/03/01/delegated-properties-in-kotlin/"},{"title":"Kotlin与DataBinding协作","text":"DataBinding 是 Google 爹地为我们这群苦逼的 Android 开发者推出的 MVVM 框架。本文解决 Kotlin 和 DataBindin 共用时报错的问题。 如下修改即可app 的 build.gradle 中添加如下部分 1234567dependencies { // ... kapt 'com.android.databinding:compiler:1.0-rc5'//改为对应版本}kapt { generateStubs = true}","link":"/2016/03/08/android-databinding-with-kotlin/"},{"title":"博客迁移到 Hexo","text":"Github Pages 服务的 Jekyll 升级了，干脆我就趁着这次机会把博客迁移到 Hexo 好了。 Hexo 是 Node.js 的一个静态博客系统，相比起 Ruby 实现的 Jekyll，它生成的速度更快而且更加现代化。当然最重要的就是对前端工程师更友好啦，毕竟是用 javascript 写的嘛 使用 Hexo 和 Jekyll 的不同点在于 Hexo 是生成静态文件后上传到 Github Pages 服务上，而 Jekyll 是上传源码然后在服务器上生成静态文件。 如何使用Hexo安装Hexo 安装 Node.js 安装 Hexo 1npm install hexo-cli -g 生成静态博客项目只需要输入以下命令就会生成一个静态博客项目 123hexo init blogcd blognpm install 然后等待 npm 安装完成 运行博客输入以下命令，然后就可以在浏览器地址栏中输入http://localhost:4000/打开博客 1hexo server 编写文章在source/_posts文件夹下放入对应格式的 markdown 文件，hexo 就会根据模板将其渲染为对应格式的 html 静态文件。 从Jekyll迁移迁移文章把_posts文件夹内的所有文件复制到source/_posts文件夹，并在_config.yml中修改new_post_name参数。 1new_post_name: :year-:month-:day-:title.md 文章格式修改Jekyll 特定的Front-matter需要删掉并且替换为对应的 Hexo 的Front-matter，并且文章的 markdown 格式可能需要修改 部署到 Github Pages和 Jekyll 类似，我们还是需要一个username.github.io的项目。但和 Jekyll 不同的是我们需要把生成的静态文件部署上去而不是将 markdown 文件部署上去。 在本地输入 123hexo g# 或者hexo generate 即可在本地生成静态页面，然后打开config.yml，修改为自己的项目信息就可以了 1234deploy: type: git repo: git@github.com:loshine/loshine.github.io.git branch: master 高级设置config.yml文件有许多的可配置选项，可以参照这里设置 主题默认情况下使用的是 landscape 主题，我们也可以在这里挑选主题 总结其实博客迁移完毕已经挺久了，我终于在今天（2016-03-22）想起来把这个过程记录下来了，也可以给其他需要迁移的人一个参考吧。","link":"/2016/03/22/migrate-blog-to-hexo/"},{"title":"背景色渐变的引导页","text":"使用什么实现还用问么，ViewPager 以及 Fragment 呀，非常简单。 关键 API下面的 API 可以根据初始颜色和结束颜色计算中间值。 1Object ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue); 具体实现布局 activity_main.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;me.loshine.guidedemo.MainActivity&quot;&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/RelativeLayout&gt; 处理滑动背景色 MainActivity.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { ViewPager mViewPager; private int[] colors; private int state = ViewPager.SCROLL_STATE_IDLE; // 初始位于停止滑动状态 private ArgbEvaluator mArgbEvaluator; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initColors(); initViewPager(); } /** * 初始化 ViewPager */ private void initViewPager() { mViewPager = (ViewPager) findViewById(R.id.view_pager); if (mViewPager != null) { // 初始颜色 mViewPager.setBackgroundColor(colors[0]); mViewPager.setAdapter(new FragmentStatePagerAdapter(getSupportFragmentManager()) { @Override public Fragment getItem(int position) { return GuideBaseFragment.newInstance(position); } @Override public int getCount() { return 4; } }); mViewPager.addOnPageChangeListener(this); } } /** * 初始化颜色 */ private void initColors() { colors = new int[4]; colors[0] = getResources().getColor(R.color.guideBackgroundColor1); colors[1] = getResources().getColor(R.color.guideBackgroundColor2); colors[2] = getResources().getColor(R.color.guideBackgroundColor3); colors[3] = getResources().getColor(R.color.guideBackgroundColor4); mArgbEvaluator = new ArgbEvaluator(); } @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { // 只要不是滑动停止状态就计算颜色 if (state != ViewPager.SCROLL_STATE_IDLE) { if (positionOffset &gt; 0 &amp;&amp; position &lt; 4) { int evaluatePreColor = (int) mArgbEvaluator .evaluate(positionOffset, colors[position], colors[position + 1]); mViewPager.setBackgroundColor(evaluatePreColor); } else if (positionOffset &lt; 0 &amp;&amp; position &gt; 0) { int evaluateNextColor = (int) mArgbEvaluator .evaluate(-positionOffset, colors[position], colors[position - 1]); mViewPager.setBackgroundColor(evaluateNextColor); } } } @Override public void onPageSelected(int position) { } @Override public void onPageScrollStateChanged(int state) { this.state = state; }} 总结其实实现方式并不复杂，监听 ViewPager 的滚动然后计算中间值即可，重要的是又学习到酷炫的新东西了。","link":"/2016/04/01/guide-with-gradual-background/"},{"title":"Anroid中的自定义View绘制","text":"虽然我们在开发中基本可以用 Android 自带的各种控件实现绝大多数的功能，但难以避免还是有一些需求是自带的控件无法实现的。这个时候我们通常会想到去 Github 上寻找开源控件，但有的东西是有成熟的实现如：ViewPager 的 Indicator。而有的就没那么容易找到了。 还有就是虽然我们平时的一些需求可以使用图片资源代替，但过多的图片资源不仅会使得应用体积增大，还会使得加载的过程中消耗不少的系统资源（内存以及 CPU）—— 我曾经就这么干过，至少这种方法做东西很快（但也很坑）。 这个时候我们就应该想到自定义 View 了，下面就讲讲我在学习自定义 View 的一些心得体会吧。 View绘制流程View 的绘制是从 ViewRoot 的performTraversals()方法开始的，其执行过程可简单概括为根据之前所有设置好的状态，判断是否需要计算视图大小（measure）、是否需要重新安置视图的位置（layout），以及是否需要重绘（draw）视图，其流程图如下所示： 而我们今天讲的自定义 View 的绘制，主要就是在是否需要重新 draw 这一步来实现。 三个绘图工具类简介要在自定义 View 中进行重新绘制，我们首先需要了解一下 Android 中的三个重要的绘图工具类，它们就是Paint(画笔)、Canvas(画布)以及Path(路径)。当然其实不仅仅只有这三个可以作用于画图和图像处理，但它们是最基础的。 PaintPaint 就是画笔，在 Android 图形绘制的时候，我们就好像真的有一个人拿着画笔把图像画出来一样，所以画笔这个类也给了我们和现实世界作画的时候一样的一些设定。 我们可以通过 Paint 来设定线宽(就像现实中画笔的粗细)、颜色(颜料)、透明度以及填充风格等。 我们可以通过它的构造函数来新建一个画笔 1Paint paint = new Paint(); 然后对它进行一些设定 1234567891011121314151617181920212223242526272829303132paint.setARGB(255, 255, 0, 0); // 设置 ARGB 颜色 intpaint.setAlpha(0); // 设置透明度 intpaint.setColor(getResources().getColor(android.R.color.black)); // 设置颜色paint.setAntiAlias(true); // 开启抗锯齿paint.setDither(true); // 开启抖动处理，使得绘制的图形更清晰paint.setFilterBitmap(true); // 滤掉对Bitmap图像的优化操作,加快显示速度paint.setMaskFilter(maskFilter); // 添加滤镜paint.setColorFilter(colorFilter); // 设置颜色过滤器paint.setPathEffect(pathEffect); // 设置路径效果(如虚线等)paint.setShader(shader); // 设置渐变效果paint.setShadowLayer(2, 2, 2, Color.GRAY); // 半径2,x,y 距离为2，颜色灰色的阴影paint.setStyle(Paint.Style.FILL_AND_STROKE); // 画笔样式(内部、边框还是both，画封闭图形的时候比较重要)paint.setStrokeCap(Paint.Cap.SQUARE); // 方形笔刷paint.setStrokeJoin(Paint.Join.MITER); // 各图形的结合方式paint.setStrokeWidth(2); // 画笔粗细paint.setXfermode(xfermode); // 图形重叠时的处理方式paint.setFakeBoldText(true); // 模拟粗体paint.setSubpixelText(true); // 提升文字在 LCD 的显示效果paint.setTextAlign(Paint.Align.CENTER); // 文字对齐方向paint.setTextScaleX(0.5); // 文字 X 轴缩放paint.setTextSize(40); // 文字大小paint.setTextSkewX(30); // 文字倾斜度paint.setTypeface(Typeface.SANS_SERIF); // 字体风格paint.setUnderlineText(true); // 下划线paint.setStrikeThruText(true); // 删除线paint.setStrokeJoin(Paint.Join.ROUND); // 结合处风格paint.setStrokeMiter(30); // 画笔倾斜度paint.setStrokeCap(Paint.Cap.ROUND); // 拐角处风格paint.ascent(); // baseline之上至字符最高处的距离paint.descent(); // baseline之下至字符最低处的距离paint.clearShadowLayer(); // 清除阴影// 等等 但我们光有画笔还是不够的，我们至少还需要画布(Canvas)才可以真正开始作画呢。 CanvasCanvas 就是画布，我们有了画笔和画布就可以开始作画(图形绘制)了。 我们有两种创建 Canvas 的方法： 12Canvas canvas = new Canvas();Canvas canvasByBitmap = new Canvas(bitmap); 其中传入 Bitmap 的方法会将 Bitmap 作为画布的背景。 下面是常用的drawXXX()方法，它们被用于绘制不同的图形 12345678910canvas.drawRect(new RectF(0, 0, 100, 100), mPaint); // 绘制一个方形canvas.drawRect(0, 0, 100, 100, mPaint); // 绘制一个方形canvas.drawPath(path, paint); // 绘制一个路径canvas.drawBitmap(bitmap, src, dst, mPaint); // 第二和第三个参数是 Rectcanvas.drawLine(0, 0, 100, 100, mPaint); // 画线canvas.drawPoint(100, 20, mPaint); // 画点canvas.drawText(&quot;这是一段文字&quot;, 0, 0, mPaint); // 画文字canvas.drawOval(new RectF(0, 0, 100, 200), mPaint); // 画方形的内切椭圆canvas.drawCircle(300, 300, 100, mPaint); // 画圆canvas.drawArc(new RectF(0, 0, 100, 100), 0, 30, true, mPaint); // 一个矩形内的扇形 还有clipXXX()方法，它们是裁剪一块新的区域用于绘图，这里就不详细说明了。 save()和restore()方法用来保存和恢复 Canvas 的状态，简单而言就是一个存档，一个恢复存档。 还有就是三个变换方法：translate(平移)、scale(缩放)以及rotate(旋转)了，它们可以控制画布的一些动作，就好像我们真实世界中作画的时候对画布的一些动作一样(除了缩放，2333)。 Path其实在有了上面两个类之后我们就已经可以开始绘制了，但还是先把 Path 也介绍完毕之后再开始真实案例吧。 Path 就是路径，有点像我们在初中数学中学习函数的时候，可以根据几个点确认画出一个函数的图形。 下面是一些常用的方法： 123456789101112path.addArc(new RectF(0, 0, 100, 100), 0, 30); // 添加一段圆弧path.addCircle(300, 300, 100, Path.Direction.CW); // 顺时针圆path.addOval(rectF, Path.Direction.CCW); // 逆时针椭圆path.addRect(rectF, Path.Direction.CW); // 添加矩形path.addRoundRect(rectF, {5, 5, 5, 5}, path.Direction.CW); // 添加圆角矩形path.isEmpty(); // 是否无路径path.transform(matrix); // 矩阵变换path.moveTo(100, 100); // 移动画笔而不绘制path.lineTo(300, 300); // 默认从(0，0)开始绘制,可以用 moveTo 移动起始点,调用 canvas.drawPath(path, paint) 绘制path.quadTo(x1, y1, x2, y2); // 绘制贝塞尔曲线,三点(起始点默认(0, 0))确认path.rCubicTo(x1, y1, x2, y2, x3, y3); // 多一个控制点的贝塞尔曲线path.arcTo(rectF, 0, 50); // 圆弧 开始绘制介绍完了三个绘制 UI 的基础类，那么我们现在来动手试试吧。难度从低到高，循序渐进完成自定义 View 中复杂图形的绘制。 我们自定义一个 View 并且要重新绘制的话，我们只需要新建一个类继承 View 并且实现onDraw(Canvas canvas)即可，View 会调用子类实现的onDraw完成绘制。 那么我们接下来的示例就只列出onDraw方法和对应的效果图了。 简单图形矩形123456@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); // 在构造函数中初始化画笔并设置为黑色 canvas.drawRect(0, 0, 100, 200, mPaint);} 线段12345@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawLine(0, 0, 100, 200, mPaint);} 圆形12345@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(100, 100, 100, mPaint);} 画布底色12345@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawColor(getResources().getColor(android.R.color.darker_gray));} 复杂图形刻度尺1234567891011121314151617181920212223@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); // 防止数字0出界 canvas.translate(0, 50); for (int i = 0; i &lt;= 100; i++) { if (i % 10 == 0) { // 带有数字的长刻度 canvas.drawLine(0, 0, 70, 0, mPaint); // 画文字 canvas.drawText(String.format(Locale.CHINESE, &quot;%d&quot;, i / 10), 100, 10, mPaint); } else if (i % 5 == 0) { // 每隔5的中等长度的刻度 canvas.drawLine(0, 0, 40, 0, mPaint); } else { // 其它小刻度 canvas.drawLine(0, 0, 30, 0, mPaint); } // 每个刻度画完之后位移 canvas.translate(0, 15); }} 手表表盘12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); // 绘制外圈圆 canvas.drawCircle(400, 400, 400, mPaint); // 绘制分针和时针 canvas.drawLine(400, 400, 400, 200, mPaint); canvas.drawLine(400, 400, 550, 400, mPaint); // 绘制刻度和文字 for (int i = 0; i &lt; 12; i++) { canvas.drawLine(400, 0, 400, 10, mPaint); canvas.drawText(String.format(Locale.CHINESE, &quot;%d&quot;, i == 0 ? 12 : i), 400, 100, mTextPaint); // 旋转画布 canvas.rotate(30, 400, 400); }} 总结其实 Android 中的图形绘制基本就是靠这三个类扩展变化而来，掌握了它们的使用方式我们也就可以定义各种各样的好看的自定义控件了。 那么我们掌握了绘制之后，我们还要考虑的就是自定义 View 的测量了，我会在之后再写一篇博文来总结我学习自定义 View 的测量的一些经验，感谢观看（虽然并不会有多少人看……）。","link":"/2016/03/26/custom-view-in-android/"},{"title":"夜间模式初探","text":"Android Support Library 23.2.0 版为我们带来了官方的夜间模式，现在我们可以很容易地为 App 开发夜间模式了。 如何使用使用起来非常简单，我们只需要将主题继承其即可 1234&lt;!-- parent 为 Theme.AppCompat.DayNight --&gt;&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight&quot;&gt; &lt;!-- Blah blah --&gt;&lt;/style&gt; 应用全局主题然后我们在程序中调用方法设置模式即可，推荐在 Application 的onCreate()中进行设置 1AppCompatDelegate.setDefaultNightMode(int mode); 它有四个可选值，分别是： MODE_NIGHT_NO： 使用亮色(light)主题 MODE_NIGHT_YES：使用暗色(dark)主题 MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题 MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO 组件主题我们也可以为某一个组件设置主题，通过getDelegate().setLocalNightMode(int mode);即可。注意如果改变了 Activity 的主题，我们需要调用recreate()重启来显示改变后的效果。 获取当前主题应用全局主题和设置相对应，非常简单 1AppCompatDelegate.getDefaultNightMode(); 组件主题如果没有为组件单独设置主题，那么将会获取全局主题，否则获取到组件的主题。 12345678910int currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;switch (currentNightMode) { case Configuration.UI_MODE_NIGHT_NO: // Night mode is not active, we're in day time case Configuration.UI_MODE_NIGHT_YES: // Night mode is active, we're at night! case Configuration.UI_MODE_NIGHT_UNDEFINED: // We don't know what mode we're in, assume notnight} 属性和资源对应夜间模式，我们会需要在不同的模式下使用不同的资源文件或不同的属性，此时我们可以新建一个带-night后缀的资源文件夹，然后再创建对应的资源文件即可，比如：drawable-night、values-night等。 此时如果应用切换到了夜间模式，将会自动使用-night后缀中对应的资源。 非夜间模式的后缀是-notnight，但是因为不是夜间模式就不会使用-night里的资源所以一般我们没必要使用这个后缀。 主题适配按照如上设置了之后还可能会出现一些问题如夜间模式下文字颜色还是黑色的所以看不清了（直接给 TextView 设置了textColor=&quot;@color/xxx&quot;，而比较建议的是直接引用主题属性或者给不同模式设置不同的资源。 如字体颜色一般使用?android:attr/textColorPrimary，图标颜色一般使用?attr/colorControlNormal等。 WebView 的主题适配WebView 因为没有特别的处理，所以我们需要通过加载特殊的 css 来完成夜间模式的适配。通过判断现在处于哪种主题然后切换对应的 css 即可。","link":"/2016/06/01/night-mode-in-android/"},{"title":"Anroid中的自定义View测量","text":"之前已经讲过了 Android 中 View 的绘制流程，上次主要讲的是onDraw方法，这次主要讲的就是在onMeasure方法中对 View 的大小进行测量。 理解 MeasureSpec要了解如何在onMeasure方法中对 View 进行测量，我们首先需要了解的就是onMeasure方法传入的两个 int 值：widthMeasureSpec 和 heightMeasureSpec。 它们都是32位的 int 值，高2位代表 SpecMode(测量模式)，低30位代表 SpecSize(对应模式下的测量大小)。通过以下的代码我们可以了解到 MeasureSpec 的原理： 12345678910111213141516171819202122232425private static final int MODE_SHIFT = 30; // Mode 的移位(高2位也就是左移30位)// 以下四个都是 Mode 常量private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;private static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;// 该方法用于组装 MeasureSpec，其中 sUseBrokenMakeMeasureSpec 是一个兼容参数，如果为 true 时可能会出错(sdk19之后默认走底下的逻辑)public static int makeMeasureSpec(int size, int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); }}// 获取 Modepublic static int getMode(int measureSpec) { return (measureSpec &amp; MODE_MASK);}// 获取 Sizepublic static int getSize(int measureSpec) { return (size &amp; ~MODE_MASK);} 因为 Android 中会有大量的 View 存在，所以必然会有很多 MeasureSpec，如果将 MeasureSpec 封装成一个对象必然会造成大量的对象内存分配，这也不难理解为什么要将其包装成一个 int 了。 SpecModeSpecMode 有三类，我们在前面的代码定义中看到了有五个常量，其中两个是作为工具存在的（MODE_SHIFT 和 MODE_MASK），另外三个就是 SpecMode 了。 UNSPECIFIED该模式下父容器不对 View 的大小有任何限制，一般不做处理。 EXACTLY父容器已经检测出 View 所需要的精确大小，此时 View 的最终大小就是 SpecSize 指定的大小。 对应 LayoutParams 中match_parent以及具体数值。 AT_MOST父容器指定了一个 SpecSize，View 不能大于这个值。 它对应于 LayoutParams 中的wrap_content。 与 Layout_Params 的关系在 View 测量的时候，会将 Layout_Params 在父容器的约束下转换成对应的 MeasureSpec，然后根据这个 MeasureSpec 确认 View 测量后的宽高。一旦 MeasureSpec 确认了，在onMesure中就可以确认 View 的测量宽高了。 match_parent: 对应 EXACTLY 精确值: 对应 EXACTLY wrap_content: 对应 AT_MOST measure 过程measure 过程要分为 View 和 ViewGroup，它们的测量是不同的 View由其measure方法完成，该方法是final关键字修饰的，无法重写。但measure会调用onMeasure，所以只需要看onMeasure如何实现即可。 1234567891011121314151617181920212223242526272829protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), HeightMeasureSpec));}public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.ATMOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result;}protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());}protected int getSuggestedMinimumHeight() { return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());} 其逻辑很简单，getDefaultSize方法中可以看出，View 的宽高由 SpecSize 决定。于是我们知道：直接继承 View 的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则使用wrap_content属性是无效的(等同于match_parent)。 所以我们可以这样实现来使得wrap_content生效： 12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int realWidth = widthSpecMode == MeasureSpec.AT_MOST ? mWidth : widthSpecSize; int realHeight = heightSpecMode == MeasureSpec.AT_MOST ? mHeight : heightSpecSize; setMeasuredDimension(realWidth, realHeight);} 在如上代码中我们只需要指定默认最小时的mWidth,mHeight即可(wrap_content的默认宽高)，其它模式下交给系统测量即可。 需要注意的是onMeasure方法中获取到的测量宽高并不一定就是控件的最终宽高，比如 RelativeLayout 中的控件会有多次测量，LinearLayout 中的子控件如果设置了weight也会有多次测量，那么第一次onMeasure的就不会准了。 ViewGroup其实就是在测量自己的宽高之后还会调用measureChildren来遍历子控件并且测量子控件的大小。 12345678910111213141516171819202122protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } }}protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} ViewGroup 是一个抽象类，其onMeasure方法是没有具体实现的，所以我们继承 ViewGroup 必须重写onMeasure，重写该方法需要进行的步骤如下： 调用super.onMeasure(widthMeasureSpec, heightMeasureSpec)处理非wrap_content的情况 单独处理wrap_content，即 SpecMode 为AT_MOST的情况 遍历子 View，并测量子 View 测量子 View 我们可以使用这几个方法 1234567891011// 使用子view自身的测量方法subView.measure(int wSpec, int hSpec);// ViewGroup 的测量子 View 方法// 某一个子view，多宽，多高, 内部加上了 viewGroup 的 padding 值measureChild(subView, int wSpec, int hSpec); // 所有子view 都是 多宽，多高, 内部调用了 measureChild 方法measureChildren(int wSpec, int hSpec);// 某一个子view，多宽，多高, 内部加上了 viewGroup 的 padding 值、margin 值和传入的宽高 wUsed、hUsedmeasureChildWithMargins(subView, intwSpec, int wUsed, int hSpec, int hUsed); 总结View 的测量基本就是如上所述了，自定义 View 需要重写onMeasure方法并对wrap_content进行特殊处理，其实说起来需要做的并不多，但原理还是满复杂的，全部了解了之后还是觉得学到了不少东西。","link":"/2016/04/22/measure-custom-view-in-android/"},{"title":"Android开发最佳实践——2.使用Kotlin开发Android","text":"引Android 的官方开发语言是 Java，那为什么我们不继续使用 Java 开发 Android 呢？可能有人会说出很多理由，如： 没有函数式的支持 Android 上只能用到 Java 6 令人烦躁的 NullPointException …… 但实际上我觉得让我们选择 Kotlin 而不是 Java 的原因只有一个：Kotlin 拥有更高的生产力。 下面我就介绍一下 Kotlin 这个语言和它的好处，以及如何使用它编写 Android 程序。 WhatKotlin 是公司 JetBrains 研发的语言（他们家代表产品有 IntellJ Idea、Android Studio 等）。他们的网站上，他们是这样描述 Kotlin 的： 为 JVM、Android 和浏览器而生的静态编程语言。 相比起其它 JVM 上的语言，它拥有无数的优点： 为 Java 作扩展而不是重写 Java，所以它的方法数相比 Groovy 和 Scala 少了很多 和 Java 可以无缝调用，完美利用 JVM 生态 面向对象和函数式的结合，支持多种范式 现代化的语法，解决了 Java 无数痛点（如 NullPointException） …… Kotlin 习语下面简单介绍一些 Kotlin 的习语，看看 Kotlin 是如何简化我们的编码的。 数据类Kotlin 中创建数据类非常简单，我们只需要如下编写代码即可： 1data class Customer(val name: String, val email: String) 使用了data class关键词之后，Kotlin 会自动帮我们生成getter(如果属性是使用var声明的则还会生成setter)、equals()、hashCode()、toString()、copy()等常用方法。 而在 Java 中写一个 JavaBean，我们需要一个个声明属性并写出它们对应的getter、setter以及其它代码，相比之下 Kotlin 的代码量小了一大半。 Lambda因为历史原因我们还在使用 Java6 编写 Android 代码，无法使用到 Java8 的新特性之 Lambda 表达式。而使用 Kotlin 的话是天生支持 Lambda 的，可以大大减少代码量。 Java ver: 123456mTextView.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view) { // todo ... }}); Kotlin ver: 1mTextView.setOnClickListener { v -&gt; // todo...} 默认非空Kotlin 里声明的类型都是默认非空的，可空的类型必须要在声明类型的时候在类型后面加一个?，而 Kotlin 也提供了语法糖来搞定null判断 123Student aStudentprintln(aStudent.name) 该aStudent永远不会为空 而如果是一个可空的 Student 123Student? bStudentprintln(bStudent?.name) 因为声明类型的时候添加了一个?表示可空，所以bStudent是可能为null的。但 Kotlin 提供的语法糖在使用的时候bStudent?.name不会产生 NullPointException。 字符串插值Java 中格式化字符串是这样的: 1String.format(Locale.getDefault(), &quot;Name: %s&quot;, student.getName()); Kotlin 中我们可以这样: 1&quot;Name: ${student.name}&quot; when 表达式Kotlin 里的 when 表达式非常强大，可以替换掉if-elseif-else 12345when (x) { is Foo -&gt; ... is Bar -&gt; ... else -&gt; ...} 总结上面讲了一些常用的 Kotlin 特性，还有更多没有写出的如：不可变集合,扩展函数,参数默认值等。 我个人的体验是使用 Kotlin 可以大大减少模版代码，让 Coding 更加愉悦。推荐在没有历史包袱的项目中使用。 但如果是有历史包袱的项目或者项目组成员不愿意去另外学习一门语言的话，那可能就无法享受到 Kotlin 的好处了，大家酌情选择即可。","link":"/2016/09/06/android-best-practice-p2-language/"},{"title":"自定义View之自定义属性","text":"定义一个控件我们先画一个简单的圆形 View，在onDraw中绘制。 1234567891011121314151617181920212223242526272829303132333435public class CircleView extends View { private Paint mPaint; public CircleView(Context context) { super(context); init(); } public CircleView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CircleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public CircleView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); init(); } private void init() { mPaint = new Paint(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawCircle(100, 100, 100, mPaint); }} 然后在布局文件中使用： 123&lt;io.github.loshine.customview.view.CircleView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后我们就可以在 preview 窗口中看到效果了 一个很简单的黑色的圆形 定义需要的属性现在我觉得黑色不好看了，我想给它换个颜色，那么一般来说可以用Paint.setColor(int color)来修改为其它的颜色。但这会让所有的 CircleView 都变成另一个颜色。 但我可能希望在一个 Activity 里的 CircleView 是红色，但在另一个中的是蓝色。 此时我们就需要给该 View 自定义属性了。 自定义属性就类似 TextView 的android:text=&quot;xxx&quot;，ImageView 的android:src=&quot;@drawable/xxx&quot;，可以给相同类型的 View 设置不同的属性展示不同的效果。 这里我们定义一个 color 属性。 声明属性名称在res/values文件夹下新建一个资源文件，叫 attrs.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这样就完成了属性名称的声明。 declare-styleable的 name 可以任意命名，只要不重复即可，但一般我们会使用自定义控件的类名方便管理。attr标签中定义的就是需要自定义的属性名称和类型。 我们有这几种类型： boolean color dimension enum flag float fraction integer reference string 声明完成之后就可以在代码中根据对应的方法获取布局中使用的自定义属性了。 获取属性构造方法我们在自定义 View 的时候 IDE 通常会提醒我们需要拥有构造函数，然后我们使用其智能提醒会发现有四个构造函数供我们选择： 1234public View(Context context);public View(Context context, AttributeSet attrs);public View(Context context, AttributeSet attrs, int defStyleAttr);public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 查看源码注释，我们知道这四个方法分别对应不同方式创建 View： View(context)：直接在代码中 new 出来 View(context, attrs)：当 View 是从布局文件 inflate 出来的时候会调用这个构造方法，使用默认的 style 和 theme。 View(context, attrs, defStyleAttr)：该方法不会被系统直接调用，我们需要手动调用。该方法相比第二个方法多了一个默认 style 的参数，它的作用就是为 View 提供一个基本的样式。 View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)：将资源文件中定义的某个样式作为默认样式。 我们在实现自定义 View 的时候，通常至少有两个构造方法（至于为什么我们后文再说），分别是View(Context context)以及View(Context context, AttrbuteSet attires)，这样我们才可以在 Java 代码中以及在布局文件中（或使用 Inflater）实例化它们。 obtainStyledAttributes看过了 View 的构造方法，我们现在就要在构造方法里获取 View 的参数了。Context这个类为我们提供了以下几个方法来获取属性： 1234obtainAttributes(AttributeSet set, int[] attrs) // 从 layout 设置的属性集中获取 attrs 中的属性obtainStyledAttributes(int[] attrs) // 从系统主题中获取 attrs 中的属性obtainStyledAttributes(int resId, int[] attrs) // 从资源文件定义的 style 中读取属性obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) // 后面详细说这个方法 我们了解一下这几个 API 的参数，然后就可以很方便的获取自定义属性了。 参数解析attrs就是我们需要获取属性集中的哪些属性，通常我们会定义一个&lt;styleable&gt;来管理所有的&lt;attr&gt;，然后我们就可以用R.styleable.someAttrs来使用这个参数了。 AttrbuteSet即我们在 xml 中定义的属性的集合，如： 12345&lt;Button android:id=&quot;@+id/dial_button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/dial&quot; /&gt; 这里我们的每一条属性都会放到 AttrbuteSet 中去，当然自定义属性也不例外。需要注意的是，style=&quot;@style/somestyle&quot;这样添加的属性也是会放进去的。 这也是我们必须要实现View(Context context, AttrbuteSet attr)的原因，因为我们需要把布局文件中定义的参数传进来处理。 defStyleAttrs这是自定义属性中可以让其在 Theme 中配置的关键，使用它作为参数会从当前 Theme 中去获取参数。 resId/defStyleRes直接从资源文件中定义的某个样式中读取。 Null注意到我们有一个方法只需要attrs作为参数，那它的属性从哪里来呢？其实是我们可以直接在 Theme 中指定属性并且用这个方法获取属性。 四个参数obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)这个方法有四个参数，我们获取到的属性可能从四个地方来：布局文件(set), defStyleAttr(主题可配置样式), defStyleRes(默认样式), NULL(主题中直接获取) 如果一个属性在多个地方都被定义了，那么它们的优先级如下： set&gt;defStyleAttr&gt;defStyleRes&gt;NULL TypedArray通过obtainStyledAttributes()我们就拿到了 TypedArray，我们需要的属性都存在里面。然后我们可以对应声明的时候的类型，使用对应的getXXX()方法来获取自定义属性，之后我们就可以使用自定义属性来绘图了。 实例我们将上述的圆形控件修改为五种不同颜色的同心圆，然后使用上面的不同定义属性的方式来定义一遍并且使用。 首先我们的圆形 View 改成这样了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CircleView extends View { private Paint mPaint; private int mColor1 = Color.BLACK; private int mColor2 = Color.BLACK; private int mColor3 = Color.BLACK; private int mColor4 = Color.BLACK; private int mColor5 = Color.BLACK; public CircleView(Context context) { this(context, null); } public CircleView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public CircleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView, defStyleAttr, R.style.default_style); mColor1 = typedArray.getColor(R.styleable.CircleView_circle_color1, Color.BLACK); mColor2 = typedArray.getColor(R.styleable.CircleView_circle_color2, Color.BLACK); mColor3 = typedArray.getColor(R.styleable.CircleView_circle_color3, Color.BLACK); mColor4 = typedArray.getColor(R.styleable.CircleView_circle_color4, Color.BLACK); mColor5 = typedArray.getColor(R.styleable.CircleView_circle_color5, Color.BLACK); typedArray.recycle(); init(); } private void init() { mPaint = new Paint(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); mPaint.setColor(mColor1); canvas.drawCircle(100, 100, 100, mPaint); mPaint.setColor(mColor2); canvas.drawCircle(100, 100, 80, mPaint); mPaint.setColor(mColor3); canvas.drawCircle(100, 100, 60, mPaint); mPaint.setColor(mColor4); canvas.drawCircle(100, 100, 40, mPaint); mPaint.setColor(mColor5); canvas.drawCircle(100, 100, 20, mPaint); }} 然后在attrs.xml中如下定义： 12345678910111213&lt;resources&gt; &lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;!-- 对应五个同心圆的颜色 --&gt; &lt;attr name=&quot;circle_color1&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;circle_color2&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;circle_color3&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;circle_color4&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;circle_color5&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt; &lt;!-- 定义 theme 可配置 style --&gt; &lt;attr name=&quot;circle_style&quot; format=&quot;reference&quot;/&gt;&lt;/resources&gt; 然后我们的style.xml中是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;!-- 配置style --&gt; &lt;item name=&quot;circle_style&quot;&gt;@style/custom_theme&lt;/item&gt; &lt;!-- 直接在主题中指定 --&gt; &lt;item name=&quot;circle_color1&quot;&gt;#ffff00ff&lt;/item&gt; &lt;item name=&quot;circle_color2&quot;&gt;#ffff00ff&lt;/item&gt; &lt;item name=&quot;circle_color3&quot;&gt;#ffff00ff&lt;/item&gt; &lt;item name=&quot;circle_color4&quot;&gt;#ffff00ff&lt;/item&gt; &lt;item name=&quot;circle_color5&quot;&gt;#ffff00ff&lt;/item&gt; &lt;/style&gt; &lt;!-- 主题中配置的style --&gt; &lt;style name=&quot;custom_theme&quot;&gt; &lt;item name=&quot;circle_color1&quot;&gt;#ffff0000&lt;/item&gt; &lt;item name=&quot;circle_color2&quot;&gt;#ffff0000&lt;/item&gt; &lt;item name=&quot;circle_color3&quot;&gt;#ffff0000&lt;/item&gt; &lt;/style&gt; &lt;!-- 直接在layout文件中引用的style，最后会被放到set中 --&gt; &lt;style name=&quot;myStyle&quot;&gt; &lt;item name=&quot;circle_color1&quot;&gt;#ff00ff00&lt;/item&gt; &lt;item name=&quot;circle_color2&quot;&gt;#ff00ff00&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;default_style&quot;&gt; &lt;item name=&quot;circle_color1&quot;&gt;#ffffff00&lt;/item&gt; &lt;item name=&quot;circle_color2&quot;&gt;#ffffff00&lt;/item&gt; &lt;item name=&quot;circle_color3&quot;&gt;#ffffff00&lt;/item&gt; &lt;item name=&quot;circle_color4&quot;&gt;#ffffff00&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在布局中我们是这样使用的： 12345&lt;io.github.loshine.customview.view.CircleView style=&quot;@style/myStyle&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:circle_color1=&quot;#ff00ffff&quot;/&gt; 如上配置，我们效果如图所示： 可以看出我们的 color4 没有起效果，这是因为使用了 defStyle，这个时候默认 Style 就不会起作用了。 参考文章深入理解Android 自定义attr Style styleable以及其应用","link":"/2016/08/13/custom-view-attrs/"},{"title":"Android开发最佳实践——1.接口设计","text":"一个项目刚开始的时候，最需要确认的就是接口设计了：数据如何传递，使用什么格式什么协议乃至如何保证安全性。如果一个项目的接口设计不合理——比如没有考虑到安全性，后期为了增加安全验证又要对部分 API 推倒重做，那么前端（泛指 Android、iOS 以及 Web）就必须对整个项目进行改动，甚至可能导致之前发布的版本无法使用的囧事。 那么本文就谈谈我认为的一个好的接口应该是如何设计的。 设计使用 RESTful 风格的 API 设计。 协议使用 HTTPS 协议，保证 HTTP 的方便的同时保证一定的安全性。 域名尽量部署在专属域名下，如 github： 1https://api.github.com/ 版本应该把版本号放到 URL 中，如 API 有改版的时候，应保证老版的 API 持续提供服务一段时间。 1https://api.example.com/v1/ 路径和资源在 Restful 风格的 API 中，每个路径都代表着互联网中的一个资源。所以 URL 地址中应该使用名词，并且因为大多是资源集合，所以应该使用复数形式。如果是有从属关系的资源，应该服从从属关系，下面给出几个例子：` https://api.example.com/v1/posts https://api.example.com/v1/posts/{postId} https://api.example.com/v1/posts/{postId}/comments HTTP 动词HTTP 动词可以完美对应数据库的增删查改操作，于是我们就把 HTTP 动词和我们的增删查改操作对应起来： GET：查询数据 POST：增加数据 PUT：更新数据(客户端提供改变后的完整资源) PATCH：更新数据(客户端更新某几条属性) DELETE：删除数据 示例下面是结合 HTTP 动词和路径提供一些示例： GET /posts ：获取所有文章 POST /posts ：创建一篇文章 GET /posts/{postId} ：获取指定 Id 的文章信息 PUT /posts/{postId} ：修改指定 Id 的文章信息(客户端需要提供全部属性) PATCH /post/{postId} ：修改指定 Id 的文章信息(客户端提供需要修改的部分属性) DELETE /post/{postId} ：删除指定 Id 的文章 GET /posts/{postId}/comments ：获取指定 Id 文章的所有评论 POST /posts/{postId}/comments ：在指定 Id 文章下创建一条评论 Query 查询在 GET 查询的时候我们不可能一次性获取所有资源，那么我们需要提供一些查询条件。 下面是一些常用的查询： ?index=2&amp;size=20 ：第二页每页20条 ?sortby=name&amp;order=asc ：按指定规则与顺序排序 …… 全局信息全局通用信息应该放在请求头里，避免使用 Query 拼接，如： APPID（Android/iOS/H5） APPVER（版本号） CHANNEL（渠道号） APP-BUILD-NUM（内部小版本号） TOKEN NETWORK（网络环境） LANGUAGE（语言） 等 传输数据Request使用 json 格式传输数据，如果需要上传文件则使用表单的形式提交。 Response使用 json 格式传输数据，Content-Type一致设定为application/json。 响应格式应该统一，下面给出一个例子： 名字 类型 含义 code int 状态码 message String 状态信息 data List or Object 数据 time long 时间戳 具体的响应如下： 123456{ 'code': 0, 'message': '获取成功', 'data': [{}, {}, {}], // 返回一个集合 'time': 1472435695000} 或者返回某一个数据： 123456{ 'code': 0, 'message': '获取成功', 'data': {}, // 返回一个对象 'time': 1472435695000} 安全为了保证客户端与服务端通信的安全，我们使用 HTTPS 协议。 在身份认证上使用 Oauth 2.0 协议，用户登录之后在客户端保存一份 token，避免在客户端持久化存储用户名和密码。之后每次访问需要身份认证的 API 时，必须携带 token 访问。 避免空指针API 设计的时候应该合理帮助前端避免空指针异常，在一些字段或者属性为空的时候应该返回默认值：如 String 返回&quot;&quot;, int 返回0, Object 返回 {}, Array or List 返回 []。 参考 从零开始的Android新项目9 - 前端用后台接口设计 RESTful API 设计指南","link":"/2016/09/01/android-best-practice-p1-interface-design/"},{"title":"在Android开发中使用Lambda表达式","text":"由于三体人对我们的科技封锁，我们无法在 Android 开发中启用 Java 1.8 的重要特性——Lambda 表达式。但现在我们可以通过一些工具启用它，然后使用 Lambda 表达式替换没有什么实际意义的单方法匿名内部类。 Lambda表达式可能有些人还不太清楚到底什么是 Lambda 表达式，这里先对 Lambda 表达式进行一个简单的介绍。 Lambda 表达式是函数式编程语言的特性，它简单的说就是一个匿名函数。 我们先看一个 Groovy 的例子： 1[1, 2, 3, 4, 5].asList().forEach { x -&gt; println x } 在这个例子中，我们使用foreach来遍历一个List并打印每一个值。我们传入了一个 Lambda 表达式：{ x -&gt; println x }，这个表达式就是我们对每一个值进行的操作，在本例中就是打印它们。 在这里 Lambda 表达式是一个映射函数，foreach接受了它作为参数，然后对List中的每一个值进行遍历。 在函数式编程语言中，函数是一等公民（first class）。它们也可以作为变量或者参数被传递而且它们也是一个类。 但在 Java 中函数并不是一等公民，如果我们需要传递一个方法，必须要有一个对象包含这个方法，然后把这个对象传递过去。 所以我们经常会见到类似这样的代码： 123456textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // do what you want... }}); 但是实际上，我们需要的只是onClick这个方法里面的内容，其它的部分（new OnClickListener）实在是没有什么实际的意义，只是一个必须的语法而已。 所以 Java 1.8 也引入了部分函数式编程的特性——Lambda 表达式。 如果使用 Lambda 表达式，上面那个例子可以被简化为这样 123textView.setOnClickListener(v -&gt; { // do what you want...}); 如果只有一行代码我们还可以省略大括号 1textView.setOnClickListener(v -&gt; doSomething()); 当啷啷~ 是不是省略了很多代码，有没有很爽的感觉。 有了 Lambda 表达式，从此我们的代码可以清爽简洁，而且看起来也很好理解：箭头的左边是形参，右边是函数体，整个 Lambda 表达式就是一个函数（就是数学中的函数）。 更多 Lambda 表达式的信息可以查看《Java 8新特性：lambda表达式》——廖雪峰。 如何使用安利了这么多 Lambda 表达式的优点，但由于众所周知的某些原因，Android 中的 Java 版本被限定在了 1.6 以下，所以也就没办法使用那么好的 Lambda 表达式了。 但 Lambda 表达式这么好，你不让我用我就不用了么？我偏要用！ 好的，有以下两种方式都可以为我们开启 Lambda 表达式，我们只需要任选其一就可以了。 RetroLambdaRetroLambda 的 Gradle 插件让我们可以在 Android 中使用 Lambda 表达式，那么我们看看如何使用它吧。 Project我们需要在项目目录下的build.gradle中加入它的classpath 123456789101112buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.1.0-alpha4' classpath 'me.tatarka:gradle-retrolambda:3.2.5' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }} 在dependencies中加入classpath 'me.tatarka:gradle-retrolambda:3.2.5' app module编辑build.gradle启用插件，并把 Java 语法调整到 1.8 在顶部启用插件1apply plugin: 'me.tatarka.retrolambda' 在android中加入以下代码段启用 1.8 的语法1234compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8} Enjoy it !~ jackjack 是 Java Android Compile Kit 的缩写，它是 Google 为 Android 推出的一个编译工具包，它的原理在这里就不详述了。它有一个特点就是可以使用 Lambda 表达式，而且配置十分简单。 准备使用 jack 我们必须要把buildTools升级到24以上，我已经升级到了24 RC。 使用编辑 app 模块中的build.gradle，在defaultConfig中加一行 useJack true，然后在android中添加如下一段代码 1234compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8} 然后就好了，是不是非常简单呢~ 总结在 Java 1.8 中的 Lambda 表达式实际上只是一个语法糖，它可以帮助我们简化代码，并且表述地更佳清晰。但 Java 目前来说并不是一门有函数式特性的编程语言，而且短期内不会加入函数式特性。如果你想使用一门拥有函数式特性的语言来写 Android Application 的话，可以考虑一下 Kotlin。","link":"/2016/03/30/use-lambda-in-android/"},{"title":"集成友盟分析和推送的一些坑","text":"最近公司的项目用到了友盟的统计和推送，在集成的过程中遇到了一点小坑，这里记录一下方便以后查阅。 集成统计获得 Appkey在集成友盟的统计 SDK 之前肯定要先注册帐号，添加新应用并获取 Appkey。 导入 SDK官网提供了两种导入方式： 下载集成 使用 Gradle 集成 在这里建议使用 Android Studio 并且使用 Gradle 集成，非常简单方便，只需要添加如下依赖即可： 123dependencies { compile 'com.umeng.analytics:analytics:latest.integration'} latest.integration代表友盟统计的最新版本，笔者使用时最新版本为6.0.0 配置项目接下来修改AndroidManifest.xml文件添加权限，填写 Appkey 以及填写渠道 id ： 123456789101112&lt;manifest……&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;application ……&gt; …… &lt;activity ……/&gt; &lt;meta-data android:value=&quot;YOUR_APP_KEY&quot; android:name=&quot;UMENG_APPKEY&quot;/&gt; &lt;meta-data android:value=&quot;Channel ID&quot; android:name=&quot;UMENG_CHANNEL&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; 以上需要把UMENG_APPKEY替换成自己的应用的 Appkey，UMENG_CHANNEL替换成对应渠道的渠道号。多渠道打包可以参考美团的多渠道打包方案。 统计页面访问我司的应用界面全部由 Fragment 呈现，Activity 只用作管理 Fragment。 按照文档首先在 Application 类中调用MobclickAgent.openActivityDurationTrack(false) 禁止默认的页面统计方式，这样将不会再自动统计Activity。 然后封装一下 BaseActivity 以统计时长： 12345678910class BaseActivity extends AppCompatActivity { public void onResume() { super.onResume(); MobclickAgent.onResume(this); //统计时长 } public void onPause() { super.onPause(); MobclickAgent.onPause(this); }} 封装 BaseFragment 以统计具体页面： 1234567891011121314151617181920class BaseFragment extends Fragment { public void onResume() { super.onResume(); // 统计页面 MobclickAgent.onPageStart(getPageName()); } public void onPause() { super.onPause(); MobclickAgent.onPageEnd(getPageName()); } /** * 默认页面名是类名，可以给子类重写 */ public String getPageName() { return this.getClass().getName(); } } 帐号统计暂时还未使用，之后补充。 混淆配置按官方文档配置混淆，以免混淆之后的错误 123456789101112-keepclassmembers class * { public &lt;init&gt; (org.json.JSONObject);}-keep public class [您的应用包名].R$*{ public static final int *;}-keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String);} 使用集成测试首先在 Application 中打开测试模式： 1MobclickAgent.setDebugMode(BuildConfig.DEBUG); 然后添加测试设备 这样所有测试数据不会进入应用正式的统计后台，只能在 管理–集成测试–实时日志 里查看，测试数据的数据就不会污染生产环境数据了。 推送服务创建应用首先需要创建应用，获取应用对应的 AppKey 和 Umeng Message Secret。 因为之前使用了友盟统计，我们需要从已有应用中添加以保证 AppKey 的唯一。 导入 PushSDK 把下载的 zip 文件解压缩（解压后的文件路径不能有中文） 把解压缩后得到的目录下的 PushSDK 当做 Module 导入到自己的工程 在之前的AndroidManifest.xml的基础上添加 123&lt;meta-data android:name=&quot;UMENG_MESSAGE_SECRET&quot; android:value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;/&gt; 编辑build.gradle添加模块 1234dependencies { // ... compile project(':PushSDK')} 权限配置若主工程的targetSdkVersion为 23 及以上，需要运行时申请存储权限（WRITE_EXTERNAL_STORAGE），否则在 Android 6.0 及以上机型可能出现无法选举宿主的情况。 注册服务在工程的 Application 类的onCreate() 方法中注册推送服务，无论推送是否开启都需要调用此方法： 1234567891011121314PushAgent mPushAgent = PushAgent.getInstance(this);// 注册推送服务，每次调用 register 方法都会回调该接口mPushAgent.register(new IUmengRegisterCallback() { @Override public void onSuccess(String deviceToken) { // 注册成功会返回 device token } @Override public void onFailure(String s, String s1) { }}); 在 BaseActivity 的onCreate方法中添加如下代码启动推送统计： 1PushAgent.getInstance(context).onAppStart(); 混淆配置按照文档配置混淆 123456789101112131415161718192021-dontwarn com.taobao.**-dontwarn anet.channel.**-dontwarn anetwork.channel.**-dontwarn org.android.**-dontwarn org.apache.thrift.**-dontwarn com.xiaomi.**-dontwarn com.huawei.**-keepattributes *Annotation*-keep class com.taobao.** {*;}-keep class org.android.** {*;}-keep class anet.channel.** {*;}-keep class com.umeng.** {*;}-keep class com.xiaomi.** {*;}-keep class com.huawei.** {*;}-keep class org.apache.thrift.** {*;}-keep public class **.R$*{ public static final int *;} 集成推送中的一些坑UnsatisfiedLinkError按照如上设置之后运行项目发现会如下报错 1java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/应用包名/files/libtnet-3.1.7bk1.so&quot; is 32-bit instead of 64-bit 需要在项目根目录的build.gradle中如下设置解决： 123456defaultConfig { // ... ndk { abiFilters &quot;armeabi&quot;, &quot;x86&quot; }} 使用 BuildTypes 修改包名的错误因为友盟使用 ApplicationId 作为包名利用反射获取资源文件，而当 BuildTypes 中的 ApplicationId 改变了导致应用包名和 Java 包名不一致的时候就会导致错误。此时需要在注册推送服务之前重新设置包名： 12345678910111213141516PushAgent mPushAgent = PushAgent.getInstance(this);// 首先重新设置包名mPushAgent.setResourcePackageName(R.class.getPackage().getName());// 注册推送服务，每次调用 register 方法都会回调该接口mPushAgent.register(new IUmengRegisterCallback() { @Override public void onSuccess(String deviceToken) { // 注册成功会返回 device token } @Override public void onFailure(String s, String s1) { }}); 总结以上就是实际项目中集成友盟统计和推送的方法了，查阅资料解决了一些官方文档没有提及的东西，希望可以给后来者一个参考。","link":"/2016/10/11/umeng-analitics-and-push-service/"},{"title":"RecyclerView.Adapter：全能notify解决方案","text":"在之前我们用 ListView 或者 GridView 的时候，通知适配器刷新是这样的： 1adapter.notifyDataSetChanged(); 但是当我们使用了更强大的 RecyclerView 之后，如果直接这样通知适配器刷新将不会显示动画效果。它会直接将所有的 item 重新绘制。 我们需要使用如下的方法来通知适配器刷新，这样 RecyclerView 才会显示对应的动画效果： 1234567adapter.notifyItemInserted();adapter.notifyItemChanged();adapter.notifyItemMoved();adapter.notifyItemRemoved();adapter.notifyItemRangeChanged();adapter.notifyItemRangeInserted();adapter.notifyItemRangeRemoved(); 在这次更新的 Support Library 24.2.0 中添加了一个新的工具类，可以用来方便快捷的处理 RecyclerView.Adapter 的通知刷新。 DiffUtilDifUtil 就是这次引入的工具类，它会找出 Adapter 中每一个 Item 对应发生的变化，然后对每一个变化给予对应的刷新。 最重要的就是如下的两个重载方法 12DifUtil.calculateDiff(Callback cb, boolean detectMoves);DifUtil.calculateDiff(Callback cb); 其中DifUtil.calculateDiff(Callback cb);实际上就是DifUtil.calculateDiff(callback, true);所以我们着重研究第一个方法即可。 该方法会接收两个参数，其中第二个参数是一个 boolean 值，查看源码注释我们知道这个参数有如下作用： True if DiffUtil should try to detect moved items, false otherwise. 如果 DiffUtil 尝试检测移动的项目就设为 true，否则设为 false。 这个参数实际上是指定是否需要项目移动的检测，如果设为 false ，那么一个项目移动了会先判定为 remove，再判定为 insert。 而Callback是一个抽象类，它有四个方法需要实现： 123456789101112131415161718192021public abstract static class Callback { /** * 旧的数据源的大小 */ public abstract int getOldListSize(); /** * 新的数据源的大小 */ public abstract int getNewListSize(); /** * 该方法用于判断两个 Object 是否是相同的 Item，比如有唯一标识的时候应该比较唯一标识是否相等 */ public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition); /** * 当 areItemsTheSame 返回 true 时调用该方法，返回显示的 Item 的内容是否一致 */ public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition);} 如上所述，我们四个需要实现的方法的作用都在注释中写出了。前两个方法都很好理解，需要重点说明的是后两个 areItemsTheSame：这个方法用来判断两个 Object 是否是相同的 Item，此处最好不要简单的用equals方法判断，我们可以根据 Object 的唯一标识或者自己指定一个规则来判断两个 Object 是否是展示的相同的 Item。 areContentsTheSame：该方法只有在areItemsTheSame返回true之后才会被调用，我们在重写该方法的时候，只需要判断两个 Object 显示的元素是否一致即可。如我们有两个 Object，它们可能拥有很多属性，但是其中只有两个属性需要被显示出来，那只要这两个属性一致我们这个方法就要返回true。 使用 DiffUtils 通知刷新下面我们写一个简单的例子来学习使用 DiffUtil 首先我们来一个 Item 对应的数据类： 123456789public class Student { public String id; // 学号是唯一的 public String name; // 名字可能重复 public Student(String id, String name) { this.id = id; this.name = name; }} 然后写一个 Adapter： 1234567891011121314151617181920212223242526272829303132333435363738class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; { private final List&lt;Student&gt; datas; public MyAdapter(List&lt;Student&gt; datas) { this.datas = datas; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_recycler, parent, false); return new ViewHolder(view); } @Override public void onBindViewHolder(ViewHolder holder, int position) { holder.setData(datas.get(position)); } @Override public int getItemCount() { return datas.size(); } class ViewHolder extends RecyclerView.ViewHolder { public ViewHolder(View itemView) { super(itemView); } public void setData(Student student) { TextView textView = (TextView) this.itemView.findViewById(R.id.text); textView.setText(student.name); } }} 其对应的布局文件就是一个简单的 TextView： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;10dp&quot; tools:text=&quot;content&quot;/&gt; 然后我们在 Activity 里使用它们并显示出来： 123456789101112131415161718class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { // ... mRandom = new Random(); datas = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { datas.add(new Student(mRandom.nextInt(3000) + &quot;&quot;, &quot;Students: &quot; + i)); } mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mAdapter = new MyAdapter(datas); mRecyclerView.setAdapter(mAdapter); // ... }} 这样我们就获得了一个简单的展示学生数据的 RecyclerView 了。 然后我们对 Adapter 的数据源进行更改，并通知刷新： 1234567891011121314151617181920212223242526272829303132333435363738mFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // 创建一个原来的 List 的副本 final ArrayList&lt;Student&gt; oldTemp = new ArrayList&lt;&gt;(datas); // 更改原数据源 datas.remove(mRandom.nextInt(mAdapter.getItemCount())); for (int i = 0; i &lt; mRandom.nextInt(3); i++) { datas.add(mRandom.nextInt(mAdapter.getItemCount() - 1), new Student(mRandom.nextInt(3000) + &quot;&quot;, &quot;Students: &quot; + mRandom.nextDouble())); } // 实现 Callback DiffUtil.Callback callback = new DiffUtil.Callback() { @Override public int getOldListSize() { return oldTemp.size(); } @Override public int getNewListSize() { return datas.size(); } @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) { return oldTemp.get(oldItemPosition).id.equals(datas.get(newItemPosition).id); } @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) { return oldTemp.get(oldItemPosition).name.equals(datas.get(newItemPosition).name); } }; DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(callback); // 把结果应用到 adapter diffResult.dispatchUpdatesTo(mAdapter); } }); 效果如下： DiffUtil 的使用就是这样，根据 DiffUtil.Callback 计算出 Result，然后应用更新到 Adapter。 封装有的人可能说了，这样其实并不好用啊，我们原来数据的改变就直接使用对应的方法就可以了，你这里每次还要写得这么麻烦。那么我们就使用 DiffUtil 和 Adapter 结合再进行一次封装吧。 我们抽取一个 BaseAdapter 出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class BaseAdapter&lt;T, V extends RecyclerView.ViewHolder&gt; extends RecyclerView.Adapter&lt;V&gt;{ protected final List&lt;T&gt; temp; // 用于保存修改之前的数据源的副本 protected final List&lt;T&gt; datas; // 数据源 public BaseAdapter(List&lt;T&gt; datas) { this.datas = datas; temp = new ArrayList&lt;&gt;(datas); } protected abstract boolean areItemsTheSame(T oldItem, T newItem); protected abstract boolean areContentsTheSame(T oldItem, T newItem); @Override public int getItemCount() { return datas.size(); } public void notifyDiff() { DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffUtil.Callback() { @Override public int getOldListSize() { return temp.size(); } @Override public int getNewListSize() { return datas.size(); } // 判断是否是同一个 item @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) { return BaseAdapter.this.areItemsTheSame(temp.get(oldItemPosition), datas.get(newItemPosition)); } // 如果是同一个 item 判断内容是否相同 @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) { return BaseAdapter.this.areContentsTheSame(temp.get(oldItemPosition), datas.get(newItemPosition)); } }); diffResult.dispatchUpdatesTo(this); // 通知刷新了之后，要更新副本数据到最新 temp.clear(); temp.addAll(datas); }} 然后我们只需要令 Adapter 实现 BaseAdapter即可： 12345678910111213141516171819202122232425262728293031323334353637383940class MyAdapter extends BaseAdapter&lt;Student, MyAdapter.ViewHolder&gt; { public MyAdapter(List&lt;Student&gt; datas) { super(datas); } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_recycler, parent, false); return new ViewHolder(view); } @Override public void onBindViewHolder(ViewHolder holder, int position) { holder.setData(datas.get(position)); } @Override public boolean areItemsTheSame(Student oldItem, Student newItem) { return oldItem.id.equals(newItem.id); } @Override public boolean areContentsTheSame(Student oldItem, Student newItem) { return oldItem.name.equals(newItem.name); } class ViewHolder extends RecyclerView.ViewHolder { public ViewHolder(View itemView) { super(itemView); } public void setData(Student student) { TextView textView = (TextView) this.itemView.findViewById(R.id.text); textView.setText(student.name); } }} 之后我们如果数据源 List 中的数据有任何改动，我们只需要调用notifyDiff()就可以了： 1234567891011mFab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { datas.remove(mRandom.nextInt(mAdapter.getItemCount())); for (int i = 0; i &lt; mRandom.nextInt(3); i++) { datas.add(mRandom.nextInt(mAdapter.getItemCount() - 1), new Student(mRandom.nextInt(3000) + &quot;&quot;, &quot;Students: &quot; + mRandom.nextDouble())); } mAdapter.notifyDiff(); } }); 总结最新 Support 包中的 DiffUtil 类给我们带来了一个对 RecyclerView 的不同数据变化的统一处理方案，可以对所有数据变化之后的通知刷新简化，非常好用，强烈推荐使用。 参考Android开发学习之路-DiffUtil使用教程","link":"/2016/08/25/a-universal-solution-of-recyclerview-adapter-notify/"},{"title":"Yarn 下一代 Node 包管理器","text":"最近前端圈子里最热的话题应该就是 Facebook 新出的包管理器—— Yarn 了，它解决了前端工程师构建项目中许多痛点，类比到 Java 圈子大概就是从 Maven 切换到 Gradle 的爽快吧。 截止到10月22日，Yarn 发布短短十多天就已经达到了让人惊叹的 star 数量 这成绩简直吓死人了，那么接下来就稍微介绍一下它为什么好，为什么这么多人想要用它替换掉 NPM，以及我们该如何使用它吧。 简介简介还用怎么说呢，你只需要知道它是用来替换 NPM 的就可以了。 特性本地缓存类似 Gradle，Yarn 会把使用过的模块在本地缓存一份，如果下次还要用到相同版本的模块，那么将会直接使用本地的而不是访问网络重新获取一份。 这个特性碾压 NPM 了啊有木有！我之前使用 NPM 的时候一直想吐槽这个来着，如果全局安装项目就会依赖环境，如果不全局安装那么每个项目都要重新下载一次包，浪费时间和资源。 安全性安装之前会验证文件完整性，所以不用担心安装到损坏的文件啦 可靠Facebook 都把它用在生产环境中了，Google 也要参与维护了，Github 上那么多的 star，绝壁可靠了吧 更优雅的命令命令相比起 NPM 更容易理解，默认的设置足够贴心，感觉要起飞了 使用说了这么多也心动了，那么我们就开始安装 Yarn 吧。 安装 笔者使用的是 Mac，所以只会介绍 Mac 的安装方法，其它方式请参照 Installation Guide Mac 上有三种安装方式，推荐使用 Homebrew 安装。 Homebrew安装输入以下命令即可 12brew updatebrew install yarn 如果使用 NVM 的话，可以删除依赖中的 node： 1brew uninstall node 安装脚本下载官网提供的安装脚本来安装 1curl -o- -L https://yarnpkg.com/install.sh | bash npm 安装这是最不推荐的一个方式 1npm install --global yarn 验证安装成功选择以上三个方法之中的任意一种安装成功之后，运行如下命令检测是否安装成功 1yarn --version 如果提示没有命令，去修改.zshrc（或.profile, .bashrc）添加如下语句 1export PATH=&quot;$PATH:$HOME/.yarn/bin&quot; 常用命令安装完毕了，那么就要使用它了，下面是一些常用命令和 NPM 对应命令的对照表 作用 NPM 命令 Yarn 命令 安装 npm install yarn 安装某个包 npm install xxx —save yarn add xxx 删除某个包 npm uninstall xxx —save yarn remove xxx 开发模式下安装某个包 npm install xxx —save-dev yarn add xxx —dev 更新 npm update —save yarn upgrade 全局安装 npm install xxx –global yarn global add xxx 还有一些包发布者才会用到的命令就不作详细讲解了 总结yarn 目前来说已经可以做到替换 npm 了，赶紧使用它换取更高的工作效率吧，Enjoy it~","link":"/2016/10/22/yarn-next-generation-node-package-manager/"},{"title":"新兴效率数据库——ObjectBox","text":"今天看新闻，发现 GreenDao 的东家 greenrobot 出了一个新的 NoSQL 数据库，greenrobot 称它是目前性能最好且易用的 NoSQL 数据库，且优于其它数据库 5~15 倍的性能。 特性首先为什么我们需要这个数据库，greenrobot 介绍了它的5个特性： 快 : 比测试过的其它数据库快 5~15 倍 面向对象的 API : 没有 rows、columns 和 SQL，完全面向对象的 API 即时的单元测试 : 因为它是跨平台的，所以可以在桌面运行单元测试 简单的线程 : 它返回的对象可以在任何线程运转 不需要手动迁移 : 升级是完全自动的，不需要关心属性的变化以及命名的变化 使用安装首先要如下修改 gradle 来添加依赖： 123456789101112131415161718192021222324252627buildscript { repositories { jcenter() mavenCentral() maven { url &quot;http://objectbox.net/beta-repo/&quot; } } dependencies { classpath 'io.objectbox:objectbox-gradle-plugin:0.9.6' }} apply plugin: 'com.android.application'apply plugin: 'io.objectbox' repositories { jcenter() mavenCentral() maven { url &quot;http://objectbox.net/beta-repo/&quot; }} dependencies { compile 'io.objectbox:objectbox-android:0.9.6'} 初始化在 Application 中初始化： 12// 在 Application 中初始化boxStore = MyObjectBox.builder().androidContext(App.this).build(); EntityEntity 是需要被持久化保存的类。我们需要用@Entity注解来标注它，属性通常 private 修饰，然后会自动生成 getter、setter。 ID在 ObjectBox 中，每一个 Entity 都需要有long类型的 ID 属性，我们需要使用@Id来标注它。 12345678@Entitypublic class User { @Id private long id; ...} ID 有以下需要注意的点： 0 代表对象还没被持久化，一个新的需要被持久化的对象的 Id 应为 0 如果需要使用服务器端已经存在的 Id，需要这样标记@Id(assignable = true)，这样就不会检查插入对象时对象的 Id 属性通常我们不需要在属性上使用注解，除非： 需要指定特殊的存储在数据库中时的名称，使用@Property注解 不需要持久化该属性，使用@Transient注解 1234567891011@Entitypublic class User { @Property(nameInDb = &quot;USERNAME&quot;) private String name; @Transient private int tempUsageCount; ...} 索引使用@Index注解可以生成索引，加快查询速度。 123456789@Entitypublic class User { @Id private Long id; @Index private String name;} 关联使用@Relation注解可以标注关联关系。 一对一customId 属性会自动生成。 1234567891011121314@Entitypublic class Order { @Id long id; long customerId; @Relation Customer customer;}@Entitypublic class Customer { @Id long id;} 一对多一对多的时候，只能修饰 List。 1234567891011121314151617@Entitypublic class Customer { @Id long id; // References the ID property in the *Order* entity @Relation(idProperty = &quot;customerId&quot;) List&lt;Order&gt; orders;}@Entitypublic class Order { @Id long id; long customerId; @Relation Customer customer;} Query首先要获取 Box 对象，然后通过 QueryBuilder 查询，以下是一个找出 firstName 是 Joe 的例子： 12Box&lt;User&gt; userBox = boxStore.boxFor(User.class);List&lt;User&gt; joes = userBox.query().equal(User_.firstName, &quot;Joe&quot;).build().find(); QueryBuilder 还提供了形如greater、startsWith等 API，使用非常方便。 分页12Query&lt;User&gt; query = userBox.query().equal(UserProperties.FirstName, &quot;Joe&quot;).build();List&lt;User&gt; joes = query.find(10 /** offset by 10 */, 5 /** limit to 5 results */); offset: 查询的第一项的 offset limit: 查询多少项 查询的结果可以直接修改和删除，会同步数据库更改结果。 InsertBox 对象的put方法可以插入对象，通常主键的值是 0，如果服务器已经确定主键了需要添加注解标注。 性能对比笔者简单测试了一下和 Realm 对比的性能差距，以 2000 个简单对象为例： Insert生成 2000 个对象一次性插入数据库 objectbox：39ms realm：127ms Query查询所有 2000 条数据 objectbox：22ms realm：40ms Delete删除所有 2000 条数据 objectbox：20ms realm：47ms 可以看出 ObjectBox 性能确实比 Realm 优秀。 更复杂的性能对比后期再测试。 总结虽然现在还未到 1.0 正式版，但 ObjectBox 确实是值得期待的优秀数据库。有高性能要求的 APP 建议使用。","link":"/2017/02/07/android-db-object-box/"},{"title":"Android开发最佳实践——3.项目架构篇","text":"项目的架构是一个项目的基础，其决定了我们项目后期的可扩展性，开发过程中的便捷性等。一个好的项目架构应该是结构清晰，可维护性好且可扩展性强的。这次我们就来探讨一下如何架构一个项目。 架构选择目前 Android 主流的项目架构的选择其实并不少，我们可以选择看一下 android-architecture 这个项目，这是 Google 提供的架构例子，里面包括了目前 Android 项目的主流架构： todo-mvp/ - 基本的 MVP 架构 todo-mvp-loaders/ - 基于 todo-mvp, 使用 Loaders 获取数据. todo-databinding/ - 基于 todo-mvp, 使用 Data Binding 库. todo-mvp-clean/ - 基于 todo-mvp, 使用了 Clean 架构. todo-mvp-dagger/ - 基于 todo-mvp, 使用 Dagger2 依赖注入 todo-mvp-contentproviders/ - 基于 todo-mvp-loaders, 使用 Loaders 和 Content Providers 获取数据 todo-mvp-rxjava/ - 基于 todo-mvp, 使用 RxJava 处理并发并抽象数据层. …… 另外除了 Google 列出的架构，还有 Facebook 推出的 Flux 架构也值得考虑。 以上的架构实际上并不是互斥的，在项目中是可以同时用到的。 Clean or Flux首先我们对比一下 Clean 和 Flux 架构的区别： Clean 架构Clean 架构把项目按功能分为四层，对应到 Android 项目中从底到上分别是： Repository 层(对应图中 Entities，也是 MVVM 中的 Model) Domain 层(对应图中 Use Cases，如果没有复杂逻辑是可以省略的) Presenter 层(其对应的是 MVVM 中的 ViewModel) UI 层（即 MVVM 中的 View） 其依赖一层一层向上，底部(内部)不会对外部产生依赖。 如果使用 Clean 架构，我还会选择以下部分实现其它功能： Databinding 实现 MVVM(Model-View-ViewModel) RxJava 处理并发并抽象数据层 使用 Dagger2 处理依赖注入 Flux 架构在 Flux 架构中，数据永远是单向流动的(不包括 Web API 以及 Rest Helper)。当我们操作界面(View)触发一个动作时，ActionCreator 会创建一个对应的 Action，并通过 Dispatcher 发送给所有订阅了这个 Action 的 Store。在 Store 处理完这个 Action 之后就会把相对应的 UI 改变的事件发送给 View 并显示出来。 下面详细讲一下 Flux 架构中对应的重要成员： ActionCreator 是一个根据语义化的 API 来创建对应的 Action 的类，当 View 触发一个行为的时候就会调用 ActionCreator 对应的方法。 Action 是简单的 POJO 类型，它只包含类型和数据，不可被更改，一旦 Action 被创建就会发送到 Dispatcher。 Dispatcher 一个 Android 应用只要一个 Dispatcher，它是一个发布-订阅(又称为观察者模式)的实现，它会把 Action 分发到所有注册过的 Store 中，所有注册过的 Store 再根据需要处理 Action 即可。 Store Store 有点类似于 MVP 模式中的 Presenter，但它只负责更新 UI 不负责响应 UI 事件。 如果使用 Flux 架构，我还会选择以下部分实现其它功能： RxJava 处理并发并抽象数据层 使用 Dagger2 处理依赖注入 之后我会再写一篇博文介绍 Flux 架构的详细实现，到时候再详细探讨 Flux 架构。 MVP or MVVM为什么不用 MVC？它过时了，可以退役了。 MVPMVP 相比于 MVC，它从 Controller 层中抽出了一层 Presenter，来负责连接 View 和 Model，这样 View 一旦触发了一个操作，调用 Presenter 的方法去找 Model 获取数据，Presenter 获取到数据处理完毕之后通知 View 更新界面。 在这个过程中 View 和 Model 不直接发生联系，所有通信通过 Presenter 传递，这样 View 中只处理界面相关的东西，逻辑相关的则交由 Presenter 处理，便于后期维护。 MVVMMVVM 其实是对 MVP 的改进，它使用了双向绑定(data-binding)，View 的变化会直接更新到 ViewModel 中，ViewModel 的变化也会直接反应在 View 上，其它和 MVP 没有区别。 在 Google 推出了 Databinding 库之后使用 MVVM 可以大幅减少代码量，非常方便。 总结Clean 或 Flux 架构都是不错的架构模式，Clean 更为常见一些。而 MVP 和 MVVM 模式也是目前主流的选择，当前新开启一个项目的话可以考虑使用它们构建项目架构。 参考 文中部分图片和概念出自《MVC，MVP 和 MVVM 的图示——阮一峰》 Flux 部分参考自AndroidFlux","link":"/2016/11/17/android-best-practice-p3-project-architechture/"},{"title":"记一次升级LEDE后的坑——从0开始编译ssr","text":"今天手贱，把手里的 NETGEAR WNDR4300 从 OpenWRT 15.05 升级到了 LEDE 17.01.4。虽然配置保留了，但比较悲剧的是之前安装的 ssr 和其他服务都没了，需要重新安装。但安装完 ssr 之后更坑的来了：github 上直接下载的编译好的包是 for OpenWRT 的，LEDE 需要自行编译，于是就只能自己动手，丰衣足食了。 Warning 千万别妄图在 Mac 上直接编译，貌似缺少包还是什么的，浪费了我很多时间。 Windows 也别异想天开了 如果你会用 Docker，可以考虑用 Docker，否则选择虚拟机、真机安装 Ubuntu、购买一台 VPS 都是不错的选择。 因为我手头有一台 VPS，于是选择了 ssh 远程连接，在 VPS 上编译之后用 sftp 下载到本机的方式。 编译环境搭建我的编译环境是 Ubuntu 16.04，其它 Linux 不敢保证一定 OK，可以自行尝试 安装编译环境依赖包这是网上搜来的 OpenWRT 编译环境需要的包。 123456789101112131415161718sudo apt-get update &amp;&amp; sudo apt-get upgradesudo apt-get install build-essentialsudo apt-get install subversionsudo apt-get install git-coresudo apt-get install libncurses5-devsudo apt-get install zlib1g-devsudo apt-get install gawksudo apt-get install flexsudo apt-get install quiltsudo apt-get install libssl-devsudo apt-get install xsltprocsudo apt-get install libxml-parser-perlsudo apt-get install mercurialsudo apt-get install bzrsudo apt-get install ecjsudo apt-get install cvssudo apt-get install unzipsudo apt-get install wget 按照文档安装依赖项目地址：openwrt-ssr 按照要求安装依赖： 1sudo apt-get install gawk libncurses5-dev libz-dev zlib1g-dev git ccache 下载 LEDE SDK在 release 页面找到对应版本对应芯片的 sdk，比如我是 17.01.4，ar71xx，nand，所以我是这个lede-sdk-17.01.4-ar71xx-nand_gcc-5.4.0_musl-1.1.16.Linux-x86_64.tar.xz 在 VPS 里下载 SDK 1wget https://downloads.lede-project.org/releases/17.01.4/targets/ar71xx/nand/lede-sdk-17.01.4-ar71xx-nand_gcc-5.4.0_musl-1.1.16.Linux-x86_64.tar.xz 解压压缩包 12xz -d lede-sdk-17.01.4-ar71xx-nand_gcc-5.4.0_musl-1.1.16.Linux-x86_64.tar.xztar xvf lede-sdk-17.01.4-ar71xx-nand_gcc-5.4.0_musl-1.1.16.Linux-x86_64.tar 编译 ipk进入 SDK 目录1cd lede-sdk-17.01.4-ar71xx-nand_gcc-5.4.0_musl-1.1.16.Linux-x86_64 安装 feeds依次运行如下命令安装 feeds 12345./scripts/feeds update./scripts/feeds install zlib./scripts/feeds install libopenssl./scripts/feeds update packages./scripts/feeds install libpcre 获取 Makefile使用 git 获取项目 1git clone https://github.com/ywb94/openwrt-ssr.git package/openwrt-ssr 选择要编译的包建议选择原始版本，如果需要 GFWList 版本的请按项目页面操作 12# luci -&gt;3. Applications-&gt; luci-app-shadowsocksR 原始版本make menuconfig 开始编译首先是语言文件 123456#如果没有安装po2lmo，则安装（可选）pushd package/openwrt-ssr/tools/po2lmomake &amp;&amp; sudo make installpopd#编译语言文件（可选）po2lmo ./package/openwrt-ssr/files/luci/i18n/shadowsocksr.zh-cn.po ./package/openwrt-ssr/files/luci/i18n/shadowsocksr.zh-cn.lmo 然后正式开始编译，输入以下命令之后静待编译完成即可。 12# 开始编译make package/openwrt-ssr/compile V=99 安装 ipk编译好的 ipk 文件位于 SDK 下/bin/packages/{架构}/base目录，现在只需要将其放到路由器里安装就可以了。 windows 可以用 WinSCP，而 Mac 就只能用命令了 1scp -r luci-app-shadowsocksR_1.2.1_all.ipk root@{路由器IP}:/tmp 然后使用 ssh 工具登录路由器，进入/tmp目录，安装 ipk 包即可。 1opkg update &amp;&amp; opkg install luci-app-shadowsocksR_1.2.1_all.ipk 安装过程中会自动安装缺失的依赖，如果没有安装依赖通常是因为 update 失败了，这个时候我们可以把 opkg 源换成中科大的源 \b```vim /etc/opkg/distfeeds.conf 然后把所有的`https://downloads.lede-project.org/`换成`https://mirrors.ustc.edu.cn/lede/`，编辑完成之后重新运行如上命令即可。","link":"/2017/11/26/build-lede-ssr/"},{"title":"Fuck gfw!","text":"前天早晨9点左右，GFW 又封锁了一大批 IP，我的服务器也遭受了无妄之灾。但没办法，做 Android 的必须要用 Google 查资料，还是得折腾一下。 换 IP第一步肯定是需要把你的服务器地址换成国内可以 ping 通的，这个看服务商了。搬瓦工在 IP 被 GFW ban 掉之后，必须花钱才给换，其它服务商可以切机房换 IP 的就一直换到 IP 可以 ping 通为止就行了。 搬瓦工换 IP 可以参照《搬瓦工IP被封后，后台自助付费更换新IP教程（仅需8美元）》 安装 Shadowsocks 建议安装 Shadowsocks 而不是 Shadowsocksr，毕竟 Shadowsocksr 已经没有人继续维护了。 搬瓦工用户建议不要在 KVM 中一键安装，最好 ssh 连接服务器自行安装。 在搬瓦工 KVM 中重装系统，选择centos-7-x86_64-bbr，该镜像有 Google bbr 加持，理论上可以提升速度。 \b\b安装完系统之后使用ssh连接服务器，根据《CentOS下shadowsocks-libev一键安装脚本》这篇文章安装即可。 建议选择aes-256-gcm加密算法，端口选择常用端口，密码用生成器生成强密码。 安装 simple obfssimple obfs 是一个简单的流量混淆的工具，用于帮助我们欺骗 GFW，以减小被封的几率。 服务端安装和配置可以参考《如何安装和配置simple-obfs服务端》 客户端WindowsWindows 客户端看上述服务端的文章即可。 MacMac 用户需要使用 shadowsocks-libev 可以参照《OS X 下的科学上网完整配置方案》和《在macOS X中安装Shadowsocks和Simple Obfs》设置。 AndroidAndroid 需要自行在下载页下载插件，然后在客户端中开启。 建议 hostname 设为国内的域名，如：www.baidu.com,www.163.com等。 结语享受自由吧","link":"/2018/01/26/fuck-gfw/"},{"title":"你好，React Native","text":"React Native 现在依然是最成熟且最🔥的跨平台应用解决方案，那么我先来个 Hello world 吧。 以下所有教程都是基于 macOS，其它系统环境请参考官方文档。 安装安装 🍺 Homebrew\b\bHomebrew 是一个 Mac 下的二进制软件包管理工具，安装参考官网即可。 安装 nvmnvm \b是一个 node.js 的版本管理工具，\b\b我们可以参考文档安装。 安装 node.js安装完毕 nvm 之后，就可以输入命令 1nvm ls-remote \b检查所有 node.js 的版本了，然后在里面选择一个版本号安装即可 1nvm install version_code 安装 IDE\b如果想开发 iOS 应用则安装 Xcode，Android 则安装 Android Studio。 开发工具推荐建议使用 Visual Studio Code，安装 React Native Tools 插件。 Hello World打开终端依次运行下列命令。 123react-native init AwesomeProjectcd AwesomeProjectreact-native run-android \b\b在应用运行之后，也可以修改App.js中的代码，然后摇晃手机选择 Reload JS 就可以看到代码改动了。","link":"/2018/03/09/react-native-hello-world/"},{"title":"V2ray 穿墙攻略","text":"好吧，GFW 赢了。我的搬瓦工又被 ban 了，只能换 gcloud 然后用 v2ray 试试了，看能撑多久。 v2ray简单的说就是一个建立网络的程序，我们把本地机器的流量转发到墙外的机器，让墙外的机器获取我们获取不到的信息，再转发给我们就实现了翻墙。 vps 选择因为我的 Bandwagon cn2 已经被 ban 了两次 ip 了，这次我就扔那里看多久解封，不想再花钱了。 然后选择了 google cloud，因为有 $300 的一年试用，所以第一年基本可以算是免费了。 gcloud 设置镜像选择 Ubuntu 16.04 LTS，注意要申请固定外网 IP，否则每次重启都是一个新 ip。 防火墙策略进站出站全开 勾选允许连接到串行端口，然后添加本机的 ssh 公钥，之后就可以 ssh 直接链接 gloud 管理了。 安装 v2rayssh 连接服务器 1bash &lt;(curl -s -L https://233blog.com/v2ray.sh) 然后选择安装，跟着终端提示输入选择一步一步完成即可。 之后会显示你设置的信息，然后安装对应的客户端设置完毕就可以使用了。 客户端Android建议使用 BifrostV Win建议使用 v2rayN Mac只有 v2rayX 设置都非常简单，按照提示进行即可。 总结呼吸自由的空气吧。","link":"/2018/03/05/v2ray/"},{"title":"Android开发最佳实践——4.Repository 层实现","text":"转眼就 2017 年了，原本定的博客计划因为太忙而搁置了两个月，最近终于可以恢复更新了。今天要阐述的是我理解的完美 Repository 层的实现，Repository 层也就是我们的数据层，在这里封装了获取网络数据、缓存数据、数据库数据以及数据转换逻辑 DOdata class即 Domain Object，业务实体类。通常会用一个 Java Bean 来描述它，这里我们用 Kotlin 的 data class 实现： 123456789data class Article(@SerializedName(&quot;_id&quot;) val id: String, val desc: String, val source: String, val type: String, val url: String, val used: Boolean, val who: String?, val createdAt: Date, val publishedAt: Date) 使用了data class关键词之后，Kotlin 会自动帮我们生成getter(如果属性是使用var声明的则还会生成setter)、equals()、hashCode()、toString()、copy()等常用方法。 而在 Java 中写一个 JavaBean，我们需要一个个声明属性并写出它们对应的getter、setter以及其它代码，相比之下 Kotlin 的代码量小了一大半。 Parcelable很多情况下我们需要 DO 实现Parcelable以便我们在 Android 中传输数据，这个时候如果手写大量的代码是非常麻烦的一件事情，我们可以使用Parceler节约开发时间和代码量。 但出于兼容性原因，所有 DO 的属性都要是 Optional 1234567891011@Parcel(Parcel.Serialization.BEAN)data class Content(@SerializedName(&quot;_id&quot;) val id: String? = null, val createdAt: Date? = null, val desc: String? = null, val publishedAt: Date? = null, val source: String? = null, val type: String? = null, val url: String? = null, val used: Boolean = false, val who: String? = null) 然后我们就可以这样传输一个 DO 了： 1234// 把一个 Content 包装成一个 Parcelableval parcelable: Parcelable = Parcels.wrap(Content())// 把一个 Parcelable 解包为一个 Contentval content: Content = Parcel.unwrap(parcenlable) RealmObject讲真，我不建议使用 Realm，不仅侵入性较强，而且使用 RxJava 的时候有线程切换的问题产生。 在严格分层的应用中查询数据要跨线程传输，而此时 Realm 因为查询出来的结果不能跨线程使用必须 copy 对象，所以效率并不比其它数据库高。 DataStore and Cache在数据库的选择中因为 Realm 的线程切换以及侵入性问题，第一时间就排除掉了。 然后是 SQL 和 NoSQL 的选择，Android 中的 SQL 只有 Sqlite，而基于开发的便利性使用的框架都会对项目造成一定的侵入性。 最后经过思考选择了 paperdb 存储数据。使用 NoSQL 还有一个好处就是缓存数据非常方便，而且还可以把以前存在 SharedPreferences 里的一些数据挪到数据库中。 项目中引入 paperdb： 1compile 'io.paperdb:paperdb:2.0' 存储和取出数据： 1234567Paper.book().write(&quot;city&quot;, &quot;Lund&quot;) // PrimitivePaper.book().write(&quot;task-queue&quot;, queue) // LinkedListPaper.book().write(&quot;countries&quot;, countryCodeMap) // HashMapval city: String = Paper.book().read(&quot;city&quot;)val queue: LinkedList = Paper.book().read(&quot;task-queue&quot;)val countryCodeMap: HashMap = Paper.book().read(&quot;countries&quot;) Data Cache 可以使用 paperdb 存储，Memory Cache 则使用 LruCache。 这样在 Repository 中我们就可以做到三层缓存了。 Memory Cache（LruCache） -&gt; DataStore Cache（paperdb） -&gt; Cloud（Web） 网络请求网络请求使用 okhttp + Retrofit + gson + RxJava 实现 如果不使用 Dagger 的话是这样的： DataManager.kt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647object DataManager { // OkHttp Constants const val RESPONSE_CACHE_FILE = &quot;response_cache&quot; const val RESPONSE_CACHE_SIZE = 10 * 1024 * 1024L const val HTTP_CONNECT_TIMEOUT = 10L const val HTTP_READ_TIMEOUT = 30L const val HTTP_WRITE_TIMEOUT = 10L const val MAX_MEMORY_CACHE_SIZE = 16 const val DATE_FORMAT = &quot;yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'SSS'Z'&quot; val mGson = GsonBuilder() // 2016-12-08T11:42:08.186Z .setDateFormat(DATE_FORMAT) .create() val mCache = LruCache&lt;Any, Any&gt;(MAX_MEMORY_CACHE_SIZE) lateinit var gankModel: GankModel private set fun init(context: Context, mApiHostUrl: String, isDebug: Boolean) { val cacheDir = File(context.cacheDir, RESPONSE_CACHE_FILE) val cache = Cache(cacheDir, RESPONSE_CACHE_SIZE) val client = OkHttpClient.Builder() .cache(cache) .connectTimeout(HTTP_CONNECT_TIMEOUT, TimeUnit.SECONDS) // .writeTimeout(HTTP_WRITE_TIMEOUT, TimeUnit.SECONDS) // .readTimeout(HTTP_READ_TIMEOUT, TimeUnit.SECONDS) .build() val retrofit = Retrofit.Builder() .baseUrl(mApiHostUrl) .addConverterFactory(GsonConverterFactory.create(mGson)) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(client) .build() createModels(retrofit) } private fun createModels(retrofit: Retrofit) { gankModel = GankRepository(retrofit.create&lt;GankApi&gt;(GankApi::class.java)) }} GankApi.kt 123456interface GankApi { @GET(&quot;data/Android/{size}/{index}&quot;) fun getAndroidContent(@Path(&quot;index&quot;) index: Int, @Path(&quot;size&quot;) size: Int) : Flowable&lt;ApiResult&lt;List&lt;Content&gt;&gt;&gt;} GankRepository.kt 1234567891011121314151617181920212223class GankRepository(private val mGankApi: GankApi) : GankModel { // 为了简化，这里就写了一个固定的 key，实际开发中要根据接口来修改 key val key = &quot;androidCache&quot; @Suppress(&quot;UNCHECKED_CAST&quot;) override fun getAndroidContent(): Flowable&lt;List&lt;Content&gt;&gt; { // 从网络获取数据 return mGankApi.getAndroidContent(1, 10) .handleResult() .map { DataManager.mCache.put(key, it) Paper.book().write(key, it) it } // 把内存缓存、磁盘缓存的数据放在数据发射队列的最前面 .startWith(Flowable.just&lt;List&lt;Content&gt;&gt;( DataManager.mCache.get(key) as List&lt;Content&gt;? ?: Paper.book().read&lt;List&lt;Content&gt;?&gt;(key) ?: ArrayList&lt;Content&gt;())) .subscribeOnIO() }} 通用信息比如 App 版本号，客户端类型，用户ID 等都可以放在请求头中，这个时候应该使用 okhttp 的拦截器实现，这里就不展开了。 错误处理我们的接口中会包含错误类型错误码，于是对应的也会定义对应的异常信息抛给上层处理，这里使用了 kotlin 的扩展方法： 12345678910111213/** * 将 ApiResult&lt;T&gt; 拆成 T, 如果有错误返回异常 */fun &lt;T&gt; Flowable&lt;ApiResult&lt;T&gt;&gt;.handleResult(): Flowable&lt;T&gt; { return flatMap { if (it.error) { // 此处要根据 errorCode 定义对应的自定义异常，demo为了省事简写了 Flowable.error&lt;T&gt;(Exception(&quot;error&quot;)) } else { Flowable.just(it.results) } }} SharedPreferences虽然说我们使用了 paperdb，可以替代大多数情况下 SharedPreferences 的使用，但在使用设置界面时还是推荐使用 SharedPreferences，因为系统的 PreferenceFragment 可以为我们节省大量的代码，节约开发时间。 那么这个时候还是没办法避免使用 SharedPreferences 了，这里提供一个使用 Kotlin 委托属性 实现的 SharedPreferences 委托类： 123456789101112131415161718192021222324252627282930class Preference&lt;T&gt;(val context: Context, val name: String, val default: T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun &lt;U&gt; findPreference(name: String, default: U): U = with(prefs) { val res: Any = when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;This type can be saved into Preferences&quot;) } res as U } private fun &lt;U&gt; putPreference(name: String, value: U) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;This type can be saved into Preferences&quot;) }.apply() }} 在代码中我们可以如下使用 1234567class WhateverActivity : Activity() { var aInt: Int by Preference(this, &quot;aInt&quot;, 0) fun whatever() { println(aInt) // 会从 SharedPreference 取这个数据 aInt = 9 // 会将这个数据写入 SharedPreference }} 总结这就是我心目中完美的 Repository 层（或 Data 层）实现了，也许并不是最优的，但在我看来做到了易用和效率的平衡。 以上。","link":"/2017/01/21/android-best-practice-p4-repository/"},{"title":"使用 Jenkins 打造 Android 自动构建工具流","text":"每次给测试打包应用的时候，因为编译 Andorid apk 非常消耗性能，所以基本上只能看着电脑发呆。高级的工程师怎么可以这样被难倒，于是乎我就开始了漫长的折腾之旅。 工具选择比较常用的有 Travis-ci，Jenkins，gitlab-ci 等，综合考虑了一下我的需求： 我们的 repo 在 github 上，gitlab-ci 被淘汰 私有 repo，Travis-ci 需要收费被淘汰 所以最终我选择了 Jenkins Jenkins 安装 &amp; 配置安装 Jenkinsssh 工具连上服务器，根据官方 Wiki一顿操作 1. 添加 repo1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 2. 添加 sources将下面的内容添加到/etc/apt/sources.list 1deb https://pkg.jenkins.io/debian-stable binary/ 3. 安装无须多言，照做便是 12sudo apt-get updatesudo apt-get install jenkins 配置 Jenkins如上操作完毕之后其实我们已经安装完毕了，然后我们需要配置一下 其实是我的 8080 端口已经使用了，所以要换个端口。 然后呢，如果你是用 vps，注意改一下安全策略把对应端口对外开放。 1vim /etc/default/jenkins 找到HTTP_PORT配置为你需要的端口即可 然后再运行以下命令，复制好初始密码，之后要用到的 123cat /var/lib/jenkins/secrets/initialAdminPassword******************************* 哈哈我的密码肯定不会给你看的~~ 启动1/etc/init.d/jenkins start 其它可选命令：{start|stop|status|restart|force-reload} 然后我们打开浏览器：{你的服务器 IP 地址}:{你修改的端口号} 输入你刚刚复制好的初始密码，就可以了。 选择安装建议的插件，然后设置好账号密码，就 OK 了。 安装插件包之前建议的插件包可以会漏掉一些东西，我们再装一下看有没有都装齐 Git plugin Gradle Plugin Email Extension Plugin description setter plugin build-name-setter user build vars plugin Post-Build Script Plug-in Branch API Plugin SSH plugin Scriptler Dynamic Parameter Plug-in Git Parameter Plug-In fir.im 插件fir.im 的插件需要自己安装，详情看fir.im Jenkins 插件使用方法 设置工具在这一步之前，我们先检查一下编译 Android 项目需要的依赖都有了吗 JDK我安装的 1.8 1234sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer 如果你找不到 add-apt-repository 命令，就装一下以下两个包 1sudo apt-get install software-properties-common python-software-properties 安装好了之后的的路径是/usr/lib/jvm/java-8-oracle Gradle现在我们不需要自己安装 Gradle 了，Android 项目现在是默认启用 gradle-wrapper 的，然后会自行下载和编写项目一致的 Gradle 版本 Android-Sdk这一步稍微麻烦点，首先我们去 Android 官网找到 SDK：sdk-tools-linux-3859397.zip 然后在服务器上下载： 123# 没有安装 wget 先安装 wget# sudo apt-get install wgetwget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip 解压并移动到/usr/local/android-sdk 12345# 没有安装 unzip 先安装 unzip# sudo apt-get install unzipunzip sdk-tools-linux-3859397.zipsudo mkdir /usr/local/android-sdksudo mv tools /usr/local/android-sdk 安装依赖 注：如果您运行的是 64 位版本 Ubuntu，则您需要使用以下命令安装一些 32 位库： sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6 如果您运行的是 64 位版本的 Fedora，则所用命令为： sudo yum install zlib.i686 ncurses-libs.i686 bzip2-libs.i686 更新 sdk 12cd toolssudo ./android update sdk 等待更新完毕之后，运行如下命令 1234cd ..cd tools/binsudo ./sdkmanager --updatesudo ./sdkmanager --list 然后按照需求安装对应的包即可 其他 sdkmanager 操作可以参考这里 12# 按需安装sudo ./sdkmanager &quot;platforms;android-26&quot; 配置 tools path系统管理 &gt; Global Tool Configuration JDK新增 JDK JDK 别名: JAVA_8 JAVA_HOME: /usr/lib/jvm/java-8-oracle 自动安装: 取消勾选 Git Name: Native-Git Path to Git executable: /usr/bin/git 自动安装: 取消勾选 Apply &gt; Save 系统管理 &gt; 系统设置 全局属性 Environment variables: 勾选 键值对列表: ANDROID_HOME:/usr/local/android-sdk 到此 Jenkins 的所有属性都配置完毕了。 项目我们整个理想化的流程是 本地代码 push 到 Github 的 master 分支 Jenkins 监听到 Github 的 webhook，拉取项目更新 Gradle build 输出 apk 到 fir.im 先用一个 github 上的项目测试一次 新建项目1. 创建项目输入项目名称，并选择 构建一个自由风格的软件项目 2. 填写项目资料通用因为我是一个 Github 项目，所以勾选上 Github project，并填上了项目链接 源码管理源码管理选择 Git，填入 Github 上的 Repository URL，然后添加自己的 Github 账号并选中，分支选择master 构建触发器触发构建的条件，我的需求是每次 push master 分支的时候都会触发构建，所以我勾选了 GitHub hook trigger for GITScm polling 这里注意，需要到自己的 Github 页面以及 Jenkins 的设置页面进行一些配置，详情请看 Github Plugin Wiki 构建环境可以自己按需设置，我没有要求所以跳过 构建增加构建步骤 &gt; Invoke Gradle script &gt; Use Gradle Wrapper 勾选上 Make gradlew executable Tasks 填入 clean assembleDebug 如果是打正式包，配置好签名之后 Task 填入 clean assembleRelease 构建后操作1. 上传 fir.im这里我们需要把 Build 完毕的 Android apk 上传到 fir.im，并且发邮件通知开发者。 增加构建后操作步骤 &gt; Upload to fir.im 填入申请的 Token 和其它内容即可 2. 邮件通知我们这里使用 Email Extension Plugin 安装和初始设置就不说了，直接添加最后的内容 Project Recipient List: 添加邮件接收者的邮箱地址，用,分隔 Content Type: HTML Default Subject: 构建通知: $PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS! Default Content: 123456789(本邮件是 Jenkins 服务端构建完毕后自动发送，请勿回复)&lt;br/&gt;&lt;hr/&gt;项目名称: $PROJECT_NAME&lt;br/&gt;Git 版本号: $GIT_REVISION&lt;br/&gt;触发原因: $CAUSE&lt;br/&gt;构建编号: # $BUILD_NUMBER&lt;br/&gt;构建状态: $BUILD_STATUS&lt;br/&gt;构建地址: &lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;br/&gt; Attach Build Log: Compress and Attach Build Log 触发构建全部设置完毕了，接下来我们就要去触发构建了。 我们默认设置的是 Github Webhook 的方式构建，但我现在想直接构建，所以进入项目，点击 立即构建，等待全部运行完毕即可。 一些额外的小帮助如果构建过程中 gradle wrapper 下载 gradle 可执行文件特别慢，你可以先在本机下载好，用 sftp 软件传到服务器 然后把你下载好的压缩文件移动到/var/lib/jenkins/.gradle/wrapper/dists/gradle-{version_number}-all/{strange_strings}，取消正在进行的构建，重来一次就可以了 总结为了弄 Jenkins 自动构建工具流，我来回忙活了好几天。首先在 Aliyun 上买了个 单核1G内存 的服务器，然后一直卡在transformDexArchiveWithExternalLibsDexMergerForDebug这里任务 failed 发现不要用不是稳定版的 Android Studio 来创建项目，似乎是最新非稳定版的 Gradle 和 Ubuntu 的兼容性问题。 然后呢，华丽丽的开始 Build 了之后，就，服务器整个卡死，Jenkins 无法连接，ssh 无法连接，阿里云监控也看不出啥原因，最后我猜测是内存爆了，升级到单核2G内存，并且为了减小项目的影响，新建了一个项目来 Build，就通过了。 查看阿里云内存监控发现一个刚创建的项目构建的时候内存峰值就已经快到 2G 的极限了，这没办法，只能选择更高配的机器了。但阿里云坑的是没有1核4G的可选了，只好退款换到腾讯云，然后就搞定了。 Warning: Gradle 构建项目的时候实在是太吃内存了，大家一定要选购内存足够的机器，否则会卡死。","link":"/2017/11/27/android-ci-jenkins-flow/"},{"title":"Java 引用类型","text":"Java中提供了4个级别的引用：强引用、软引用、弱引用和虚引用。这次就来探讨一下它们到底都有什么作用。 \bJava 中对于引用的类都在java.lang.ref包下 引用类型强引用(Final Reference)强引用就是最常见的Object obj = new Object()这种方式创建出来的对象引用。 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 其类定义如下： 123456class FinalReference&lt;T&gt; extends Reference&lt;T&gt; { public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) { super(referent, q); }} 软引用(Soft Reference)软引用是用来引用一些有用但非必须存在的对象的引用类型，通常是为了提高性能的缓存，在内存不足时可以被垃圾回收器回收。 对于软引用关联着的对象，如果内存充足，则垃圾回收器不会回收该对象；如果内存不够了，就会回收这些对象的内存。 弱引用(Weak Reference)用来描述非必须的对象。 被弱引用关联的对象只能生存到下一次垃圾收集发送之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用(Phantom Reference)虚引用随时会被回收，它只被用来追踪垃圾回收过程。 四种类型的分析 强引用除非手动删除引用，否则不会被 GC 回收。 软引用只在可能 OOM 时会被 GC 回收 弱引用一旦触发 GC 就会被回收 虚引用总是被回收 所有引用如果被删除了引用，将会进入引用队列，待 GC 回收","link":"/2018/03/09/java-reference/"},{"title":"Scala 隐式类","text":"Scala 2.10 引入了一种叫做隐式类的新特性。隐式类指的是用implicit关键字修饰的类。在对应的作用域内，带有这个关键字的类的主构造函数可用于隐式转换。 用法创建隐式类创建隐式类时，只需要在对应的类前加上implicit关键字: 123456789101112131415object Helpers { implicit class IntWithTimes(x: Int) { def times[A](f: =&gt; A): Unit = { def loop(current: Int): Unit = if (current &gt; 0) { f loop(current - 1) } loop(x) } }} 使用隐式类使用隐式类时，类名必须在当前作用域内可见且无歧义，这一要求与隐式值等其他隐式类型转换方式类似。 要使用上述创建好的隐式类，只需将其导入作用域内并调用times方法。 123import Helpers._5 times println(&quot;hello&quot;) 限制条件1. 只能在别的 trait/类/对象内部定义123456object Helpers { implicit class RichInt(x: Int) // 正确！}implicit class RichDouble(x: Double) // 错误！ 2. 构造函数只能携带一个非隐式参数123implicit class RichDate(date: java.util.Date) // 正确！implicit class Indexer[T](collecton: Seq[T], index: Int) // 错误！implicit class Indexer[T](collecton: Seq[T])(implicit index: Index) // 正确！ 虽然我们可以创建带有多个非隐式参数的隐式类，但这些类无法用于隐式转换。 3. 在同一作用域内，不能有任何方法、成员或对象与隐式类同名1234567object Barimplicit class Bar(x: Int) // 错误！val x = 5implicit class x(y: Int) // 错误！implicit case class Baz(x: Int) // 错误！ 总结隐式类可以用于隐式转换，创建隐式类应当注意必须在 trait/类/对象的内部定义，并且参数只能有一个。","link":"/2018/06/23/scala-implicit-classes/"},{"title":"Scala Value Class","text":"值类型(Value class)是一种通过继承 AnyVal 类来避免运行时对象分配的新机制。 值类型创建以下是一个最简单的值类型 1class Wrapper(val underlying: Int) extends AnyVal 它仅有一个被用作运行时底层表示的公有val参数。在编译期，其类型为 Wrapper，但在运行时，它被表示为一个 Int。 值类型可以带有def定义，但不能再定义额外的val、var，以及内嵌的trait、class或object 继承值类型只能继承普通 trait，但其自身不能再被继承。 普通 trait就是继承自 Any 的、只有def成员，且不作任何初始化工作的 trait 继承自某个普通 trait 的值类型同时继承了该 trait 的方法，但是（调用这些方法）会带来一定的对象分配开销。 12345678trait Printable extends Any { def print(): Unit = println(this)}class Wrapper(val underlying: Int) extends AnyVal with Printableval w = new Wrapper(3)w.print() // 这里实际上会生成一个Wrapper类的实例 用例扩展方法值类型可以和隐式类配合用来为类添加扩展方法，并且避免额外的内存开销。 123implicit class RichInt(val self: Int) extends AnyVal { def toHexString: String = java.lang.Integer.toHexString(self)} 在运行时，表达式3.toHexString被优化并等价于静态对象的方法调用RichInt$.MODULE$.extension$toHexString(3)，而不是创建一个新实例对象，再调用其方法。 确保类型安全可以额外定义一个值类型用来保证类型安全。 1234567class Meter(val value: Double) extends AnyVal { def +(m: Meter): Meter = new Meter(value + m.value)}val x = new Meter(3.4)val y = new Meter(4.3)val z = x + y 实际上不会分配任何 Meter 实例，而是在运行时仅使用原始双精浮点数(double) 。 总结值类型用于减少内存分配消耗，我们在编程中可以灵活使用提高程序性能。","link":"/2018/06/23/scala-value-class/"},{"title":"Scala 并发编程","text":"并发编程是开发中及其重要的部分，本文用于说明 scala 中的并发编程。 Future所谓 Future，是一种用于指代某个尚未就绪的值的对象。 Future 有两个状态： 待就位：等待结果 已就位：已经结束，可能接收到值或者发生异常 其中已就位也有两种情况：成功就位或发生异常。 Future 的一个重要属性在于它只能被赋值一次。一旦给定了某个值或某个异常，Future 对象就变成了不可变对象——无法再被改写。 创建 Future最简单的创建 Future 的方法就是直接使用Future.apply()方法。 假设我们使用某些流行的社交网络的假定 API 获取某个用户的朋友列表，我们将打开一个新对话(session)，然后发送一个请求来获取某个特定用户的好友列表。 1234567import scala.concurrent._import ExecutionContext.Implicits.global // 必须导入，否则会报错val session = socialNetwork.createSessionFor(&quot;user&quot;, credentials)val f: Future[List[Friend]] = Future { session.getFriends()} 监听结果注册监听onComplete方法可以在 Future 接收到结果的时候对其进行处理。 onComplete 会传递一个Try[T]类型的值，它有2个子类：Success或Failure，成功时会回传Success，失败时就是Failure。 我们可以通过模式匹配来处理： 1234f onComplete { case Success(list) =&gt; for (v &lt;- list) println(v) case Failure(e) =&gt; println(&quot;An error has occured: &quot; + e.getMessage)} 函数组合集合可用的map,flatMap等函数组合也可以使用在 Future 上。 这些组合操作方法可以帮助我们方便的转换 Future 1val f = Future { 1 }.map(v =&gt; s&quot;$v&quot;).flatMap(v =&gt; Future { s&quot;value = $v&quot; }) for 解构for关键词也可以用于解构 Future，并且方便的转换其值。 12345678910val future = for { v1 &lt;- Future{ 1 } v2 &lt;- Future{ 2 } if v1 &lt; v2} yield &quot;v1 &lt; v2&quot;future.onComplete { case Success(value) =&gt; println(value) case Failure(exception) =&gt; println(exception.getMessage)} recoverrecover通常和其它函数组合操作符一起使用，以避免发生异常之后直接结束。 12345val purchase: Future[Int] = rateQuote map { quote =&gt; connection.buy(amount, quote)} recover { case QuoteChangedException() =&gt; 0} 此时如果map的内容发生异常，会直接走到recover里检查异常并返回值。 PromisePromise 允许你在 Future 里放入一个值，不过只能做一次，Future 一旦完成，就不能更改了。 可以使用success方法传入成功的值，或者failure方法传入错误。 也可以使用complete方法传入Try[T]的子类，也就是Success[T]或Failure 1234567891011val promise = Promise[String]()// promise.success(&quot;sucess&quot;)promise.failure(new Exception(&quot;haha&quot;))try { val result = Await.result(promise.future, 3 second) println(result)} catch { case e: Exception =&gt; println(s&quot;Exception($e) happened.&quot;)} 异步转同步AwaitFuture 的onComplete方法监听是异步的，我们也可以使用 Await 来阻塞当前线程获取 Future 的值 Await 会阻塞当前线程直到获取到值或者超时。 12345678def a = Future { Thread.sleep(2000); 100 }def b = Future { Thread.sleep(2000); throw new NullPointerException }Await.ready(a, Duration.Inf) // Success(100)Await.ready(b, Duration.Inf) // Failure(java.lang.NullPointerException)Await.result(a, Duration.Inf) // 100Await.result(b, Duration.Inf) // crash with java.lang.NullPointerException async/awaitscala-async提供了类似 ES7 中提供的async/await，使用它我们可以用同步非阻塞的方式写出异步代码 我们只需要用async代替Future.apply，然后用await获取结果即可。 12345678val future = async { val f1 = async { true } val x = 1 def inc(t: Int) = t + x val t = 0 val f2 = async { 42 } if (await(f1)) await(f2) else { val z = 1; inc(t + z) }} 总结Scala 中将异步操作抽象成 Future，通过其回调可以进行异步操作。使用scala-async可以将异步转成类似同步的写法，更易于阅读。","link":"/2018/06/24/scala-parallel-and-concurrent-programming/"},{"title":"开始使用 Flutter","text":"Flutter 是 Google 出品的一项基于 Dart 的跨平台应用开发工具，理论上支持还在孵化中的 Fuchsia 和目前占据移动端大头的 Android, iOS 系统。它拥有相较于 React Native 更好的性能，Dart 的语法也很容易学习，是一门十分值得掌握的技术。 Get started以下假设读者使用 Mac，并已经安装并配置好了 Android sdk, Android Studio 等工具。 安装前的准备由于众所周知的原因，Google 的大部分网站和资源都在墙外，所以我们需要改一些环境变量来让 flutter 从一些值得信任的镜像下载工具。 在.bashrc或.zshrc中添加如下内容： 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 安装 SDK1. clone sdk把 sdk 克隆到指定目录下 1git clone -b master https://github.com/flutter/flutter.git 2. 添加环境变量在.bashrc或.zshrc中添加如下内容： 1export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH # 将 flutter 加入环境变量 3. Run flutter doctor检查工具 1flutter doctor 根据输出内容安装缺失的工具即可。 安装插件Android Studio安装 dart 和 flutter 插件。 VS Code安装 dart 和 flutter 插件。 创建工程直接使用 IDE 就可以创建工程然后运行了。 总结多的不说了，学起来吧。","link":"/2018/07/03/flutter-get-started/"},{"title":"用 Flutter 写一个 TODO 应用","text":"Google 在 Github 上提供了一个 Android 各种架构的 Todo 项目，那我就以这个项目的业务为模板用 Flutter 也实现一个。 分析我们以最基础的 todo-mvp 来分析 任务列表我们进入应用首先是一个任务列表页面，展示所有的任务列表，右上角 Menu 栏有两个按钮，分别是过滤和更多操作。 右下角是一个 FloatingActionButton，点击之后会跳转到创建任务页面。 左上角点击或者屏幕左侧滑动可以展开 DrawerView，里面可以切换到数据统计页面。 数据统计数据统计页面非常简单，就是展示有多少正在进行的任务和已结束的任务 添加、编辑任务页该页面由两个 EditText 组成，用于编辑或创建任务，EditText 分别需要填入标题和描述，右下角有一个 FloatingActionButton 用于编辑结束之后点击提交。 任务详情页任务详情页用于查看任务详情，右上角有一个 DELETE TASK Menu Item 可以删除任务，右下角 FloatingActionButton 用于进入编辑页，Checkbox 用于勾选完成任务。 开始分析完毕项目，我们就开始使用 Flutter 实现 安装 Flutter 请参考 Get started 首先需要创建项目，可以使用工具或命令行创建 数据因为涉及到本地数据存储，我们需要引入 dart 的 sqlite 操作库 sqflite 根据文档修改pubspec.yaml，然后编写数据类和数据操作类 task.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import 'dart:async';import 'package:path/path.dart';import 'package:sqflite/sqflite.dart';const tableTask = &quot;task&quot;;const columnId = &quot;_id&quot;;const columnTitle = &quot;title&quot;;const columnDescription = &quot;description&quot;;const columnCompleted = &quot;completed&quot;;const dbName = &quot;tasks.db&quot;;const String createDB = '''create table $tableTask ( $columnId integer primary key autoincrement, $columnTitle text not null, $columnDescription text, $columnCompleted integer not null)''';class Task { Task(); int id; String title; String description; bool completed; Map&lt;String, dynamic&gt; toMap() { Map&lt;String, dynamic&gt; map = { columnTitle: title, columnDescription: description, columnCompleted: completed == true ? 1 : 0, }; if (id != null) { map[columnId] = id; } return map; } Task.fromMap(Map&lt;String, dynamic&gt; map) { id = map[columnId]; title = map[columnTitle]; description = map[columnDescription]; completed = map[columnCompleted] == 1; }}class TaskProvider { static Database _db; Future&lt;Database&gt; get db async { if (_db == null) { var databasePath = await getDatabasesPath(); String path = join(databasePath, dbName); _db = await open(path); } return _db; } Future&lt;Database&gt; open(String path) async { return openDatabase(path, version: 1, onCreate: (db, version) async { await db.execute(createDB); }); } Future&lt;Task&gt; insert(Task task) async { var d = await db; task.id = await d.insert(tableTask, task.toMap()); return task; } Future&lt;Task&gt; get(int id) async { var d = await db; List&lt;Map&gt; maps = await d.query(tableTask, columns: [columnId, columnTitle, columnDescription, columnCompleted], where: &quot;$columnId = ?&quot;, whereArgs: [id]); if (maps.length &gt; 0) { return new Task.fromMap(maps.first); } return null; } Future&lt;List&lt;Task&gt;&gt; getAll() async { var d = await db; List&lt;Map&lt;String, dynamic&gt;&gt; maps = await d.query(tableTask, columns: [columnId, columnTitle, columnDescription, columnCompleted]); return maps.map((it) =&gt; Task.fromMap(it)).toList(); } Future&lt;int&gt; delete(int id) async { var d = await db; return await d.delete(tableTask, where: &quot;$columnId = ?&quot;, whereArgs: [id]); } Future&lt;int&gt; clearCompleted() async { var d = await db; return d.delete(tableTask, where: &quot;$columnCompleted = 1&quot;); } Future&lt;int&gt; update(Task task) async { var d = await db; return await d.update(tableTask, task.toMap(), where: &quot;$columnId = ?&quot;, whereArgs: [task.id]); } Future close() async { await _db?.close(); }} UIFlutter 天生支持数据绑定，UI 部分编写也不困难 需要注意的是纯展示类 UI 继承 StatelessWidget，而有状态的 UI 需要继承 StatefulWidget，然后再继承 State 来编写 UI 和属性。 StatefulWidget 有属性变化的时候需要调用setState方法，否则 UI 无法更新 具体 UI 编码可以查看 Flutter-todo 项目，这里就不具体展开了。 页面跳转需要注意的是 Flutter 一切基于 Widget，所以不区分 Activity，Fragment 这些东西的。 涉及到页面的跳转需要用 Route 来实现，而 Flutter Android 默认的 Route 动画不是很好看，所以我也实现了一个侧滑动画的 SlideRoute 总结Flutter 的使用总体来说还是比较简单的，dart 也是比较简单易学的一门语言，Flutter 的未来我也是十分看好的。接下来我需要做的就是使用一个合理的架构，如 redux 来重构一下这个项目，以及具体深入学习一下 Flutter 的机制和架构了。","link":"/2018/08/30/build-todo-app-with-flutter/"},{"title":"自己攒个黑苹果 —— 基于 Gigabyte z370n","text":"看到 Apple 新发布会发布了新款的 iMac mini，突然被种草。但转念一想 Mac mini 没有升级潜力，而且价格又太贵，不如自己来组个黑苹果吧，于是心动不如行动。 购买建议首先参照 Tonymacx86 Buyer’s Guide 购买硬件。 我购置的一套配置如下： 部件 型号 主板 Gigabyte z370n wifi CPU Intel I5 8400 内存 Crucial 8g 2666 SSD Samsung 970 EVO 500g M.2 SSD Toshiba Q200EX 256g SATA 显卡 EVGA GTX1060 6G SC 机箱 乔斯伯 TU 手提箱 电源 SilverStone ST45SF SFX 显示器 ASUS MX27AQ 2K IPS 鼠标 罗技 G102 键盘 Cherry G80-3494 红轴 在购买的时候我踩了个小坑，因为 Intel 在 H370 这一代芯片的主板上更换了新规格的网卡接口 CNVI，不兼容老的 NGFF 规格无线网卡，所以无法直接更换无线网卡达到免驱支持无线上网。 这里如果有条件最好还是购买 Z370 的主板，可以直接更换BCM94360CS2这款网卡达到免驱支持 Wifi，否则和我一样踩坑就只能插 USB Wifi 了。 最后我还是更换了 z370n 主板，并更换了BCM94360CS2，不用去操心 Wifi 和蓝牙的问题了 另外有条件的最好购买免驱的 A卡，可以安装最新的 Mac OS，不用像我需要等待 Nvidia Webdriver 适配 Mojave。 PS: 因为我的机箱没有前置的 USB 2.0 接口，所以我还购置了一个 3.0 转 2.0 转接线，安装系统的时候最好插在 2.0 接口。 安装主要步骤还是参照 Tonymacx86 Installation Guide 但因为我的显卡还没有 Mojave 的 WebDriver，所以只能安装 High Sierra 最好有一个 U 盘用来刻录系统安装，没有的话自行购买。 下载 macOS High Sierra首先从 App Store 下载 High Sierra 安装包 如果你没有 Mac，自行寻找下载方式和刻录方式 创建 USB 启动盘 插入 U 盘 打开磁盘管理 选择 U盘 抹除 名字：USB 格式：Mac OS 扩展（日志式） 抹除 下载 Unibeast 选择 U盘，UEFI 模式，显卡补丁不需要，然后等待刻录完成 下载 USBInjectAll.kext 并放入/EFI/Clover/kext/Others 下载 Multibeast，放入 U盘 设置 BIOS Save &amp; Exit → Load Optimized Defaults M.I.T. → Advanced Memory Settings Extreme Memory Profile(X.M.P.) : Profile1 BIOS → Fast Boot : Disabled BIOS → LAN PXE Boot Option ROM : Disabled BIOS → Storage Boot Option Control : UEFI Peripherals → Trusted Computing → Security Device Support : Disabled Peripherals → Network Stack Configuration → Network Stack : Disabled Peripherals → USB Configuration → Legacy USB Support : Auto Peripherals → USB Configuration → XHCI Hand-off : Enabled Chipset → Vt-d : Disabled Chipset → Wake on LAN Enable : Disabled Chipset → IOAPIC 24-119 Entries : Enabled Peripherals → Initial Display Output : PCIe 1 Slot 安装 High Sierra 插入 U 盘，选择从 U 盘启动，选择 OS X Install from Install macOS High Sierra 选择语言 使用磁盘工具把目标安装盘格式化为 Mac OS扩展（日志式） 完成重启后选择 U 盘，High Sierra 启动 驱动系统安装完成之后，就是之后的驱动安装了。 首先打开 U 盘里的 Multibeast，按如下选择(其它主板自行选择对应的驱动)即可。 123Audio: Realtek ALCxxx -&gt; ALC1220Network: Intel -&gt; IntelMausiEthernet v2.4.0USB: USBInjectAll 声卡驱动：待补USB 网卡驱动：下载地址Nvidia Webdriver：下载地址 总结我的配置目前未试验过有线网卡联网，睡眠被我禁用了，也没试验过是否可以使用。蓝牙可以直接使用，USB 无线网卡体验良好。除了 Airdrop 不可以用其它基本完美了，算是不错的 build 了。","link":"/2018/11/15/build-hacintosh-gigabyte-h370n-8400/"},{"title":"健身计划——5×5筑基计划","text":"系统开始练 5×5 差不多有 2 个月了，从零基础开始到现在三大项加起来有3倍多体重了，于是乎就好好归纳一下这个健身计划吧。 什么是 5×5这个计划的特色是每个项目做 5 组，每组做 5 次，所以就被称为 5×5 计划。 5×5 是新手的筑基计划，你可以一直使用这个计划到深蹲突破 140kg。 总纲一周三练，每次锻炼至少间隔一天。 分为两个部分 Workout A: 深蹲, 卧推, 杠铃划船 Workout B: 深蹲, 站姿推举, 硬拉 按以下每两周一个循环 StrongLifts 5x5 Week 1 周一 - workout A 周三 - workout B 周五 - workout A 深蹲 5x5 深蹲 5x5 深蹲 5x5 卧推 5x5 站姿推举 5x5 卧推 5x5 杠铃划船 5x5 硬拉 1x5 杠铃划船 5x5 StrongLifts 5x5 Week 2 周一 - workout B 周三 - workout A 周五 - workout B 深蹲 5x5 深蹲 5x5 深蹲 5x5 站姿推举 5x5 卧推 5x5 站姿推举 5x5 硬拉 1x5 杠铃划船 5x5 硬拉 1x5 如何加重如果可以完成动作，深蹲、推举、卧推、划船下次加重 2.5 kg，硬拉下次加重 5kg。 Deload如果失败了，下次继续这个重量。连续三次失败之后把重量降低到 90%，然后重新开始加重。 热身空杠做 2×5，加重 10-20 kg，做 2~3 个，然后一直持续到你的正式组。热身组不需要休息，加片的间隔时间就够了。 硬拉和划船作为最后一个动作不需要大量的热身，否则会损耗大量的体力，并且你之前的动作已经完成了热身。 划船可以考虑 60%，70%，80%，90% 各两个，然后做正式组。 硬拉可以考虑 60% 5个，正式组 -20kg 2~3 个。 目标5×5 可以一直用到新手阶段结束，到阶段 I 可能需要大量的 deload，之后可以转其它计划。 新手 阶段 I 阶段 II 进阶 深蹲 100kg 140kg 160kg 180kg 卧推 80kg 100kg 110kg 120kg 硬拉 140kg/300lb 180kg 200kg 225kg 推举 45kg 60kg 70kg 80kg 划船 70kg 90kg 100kg 110kg 锻炼时间 1-6 months 4-12 months 6-18 months 1-2 years 总结我从 2018/09/03 开始系统 5×5 训练，到现在 2018/11/20，2个半月，目前三大项成绩是： 深蹲 97.5 kg 5×5 卧推 62.5 kg 5×5 硬拉 100 kg 1×5 推举 35 kg 5×5 划船 45 kg 5×5 现在背部是最大的弱项，深蹲上次冲击 100 kg 失败，决定 deload 深蹲和硬拉，然后添加一些引体向上的训练加强背部。 5×5 计划我估计要用到深蹲破 140 kg，之后可能会转向健美计划，毕竟我不是专门练力量去比赛的，有肌肉好看就好了~","link":"/2018/11/20/body-building-program-5%C3%975-strong-lift/"},{"title":"ArrayList 源码解析","text":"ArrayList 是最常见的 List 实现，本文分析其源码和实现原理。 定义12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList 实际上是一个动态数组，容量可以动态的增长，其继承了 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。 RandomAccess 接口，被 List 实现之后，表明 List 提供了随机访问功能，也就是通过下标获取元素对象的功能。 相比较 LinkedList 未实现 RandomAccess 接口，所以无法使用下标获取元素，遍历时最好使用迭代器而不是循环遍历。 初始化要使用一个 ArrayList，首先我们要初始化它。 查看源码发现 ArrayList 有三个构造方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 默认初始容量。 */private static final int DEFAULT_CAPACITY = 10;/** * 用于空实例的共享空数组实例。 */private static final Object[] EMPTY_ELEMENTDATA = {};/** * 共享的空数组实例，用于默认大小的空实例。 * 我们将此与EMPTY_ELEMENTDATA区别开来，以知晓添加第一个元素时需要扩容多少。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/** * 存储ArrayList的元素的数组缓冲区。 ArrayList的容量是此数组缓冲区的长度。 * 添加第一个元素时，任何具有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * 的空ArrayList都将扩展为DEFAULT_CAPACITY。 */transient Object[] elementData;/** * ArrayList的大小（它包含的元素数）。 */private int size;/** * 构造一个具有指定初始容量的空列表。 * * @param initialCapacity 列表的初始容量 * @throws IllegalArgumentException 如果指定的初始容量为负 */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }}/** * 构造一个初始容量为10的空列表。 */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}/** * 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。 * * @param c 放入此列表的元素的集合 * @throws NullPointerException 如果指定的集合为null */public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { this.elementData = EMPTY_ELEMENTDATA; }} 观察其构造方法和相关的常量、变量，可以发现初始化方法都很简单，是对 elementData 进行了初始化。 常用方法解析添加元素add(E e)1234567891011/** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return true */public boolean add(E e) { ensureCapacityInternal(size + 1); elementData[size++] = e; return true;} 观察源码可以发现调用了ensureCapacityInternal(size + 1)方法，然后使 size 自增并把元素插入了 elementData 末尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity;}private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private void ensureExplicitCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);}/** * 要分配的最大数组大小。 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 增加容量以确保它至少可以容纳最小容量参数指定的元素数量。 * * @param minCapacity 所需的最小容量 */private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;} modCount 是一个防止遍历的时候更改列表的属性，调用更改列表的方法的时候都会导致其增加。 calculateCapacity方法计算容量，如果是一个默认容量空列表，那么返回 10 和 size+1 里更大的那个数；否则直接返回 size+1。 ensureExplicitCapacity方法计算是否需要扩容，如果满足扩容条件size+1-elementData.length则调用grow方法开始扩容。 grow方法是扩容方法，首先计算一个扩容后新容量，计算出的新容量默认是老容量扩容一半。然后检查传入的最小容量是否在扩容区间内，如果不在则把传入的最小容量作为扩容容量。之后检查新容量是否达到最大容量阈值，如果达到就扩容到最大容量。最后调用Arrays.copyOf方法拷贝数组。 add(int index, E element)1234567891011121314151617181920212223/** * 将指定的元素插入此列表中的指定位置。 * 将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。 * * @param index 指定元素要插入的索引 * @param element 要插入的元素 * @throws IndexOutOfBoundsException */public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;}private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 首先检查插入位置索引是否合法，然后检查是否需要扩容，再将插入位置的元素统一后移一个位置，再赋值插入位置的元素，最后 size 自增。 addAll 系列addAll 方法是以上两个方法的多元素版，源码类似不再赘述。 删除元素remove(int index)根据索引删除元素 123456789101112131415161718192021/** * 删除此列表中指定位置的元素。将所有后续元素向左移动（从其索引中减去一个）。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException */public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 检查索引是否合法，取出对应索引元素，将 elementData 索引位置之后的所有元素向前移动一个位置，最后返回索引元素。 remove(Object o)删除指定元素 12345678910111213141516171819202122232425262728293031/** * 从此列表中删除第一次出现的指定元素，如果不存在该元素就不改变列表. * * @param o 要从此列表中删除的元素 * @return 如果列表里有该元素则返回 true */public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false;}private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work} 找出 elementData 里对应元素的位置，如果存在就将后面所有元素往前移动一个位置，并将最后一个位置设置为 null。 removeAll(Collection&lt;?&gt; c)123456789101112131415161718192021222324252627282930313233public boolean removeAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); return batchRemove(c, false);}private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if (w != size) { // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified;} 检查 c 不为 null，就开始调用batchRemove移除元素。 batchRemove第二个参数用于标记是否删除补集，此处传入false表示删除交集。原理非常简单，遍历 elementData，如果集合不包含 elementData 中的元素则将此元素放到前面的位置。finally 块中对异常进行特殊处理，然后将后面的角标位置元素置空。 retainAll删除非并集的元素。 1234public boolean retainAll(Collection&lt;?&gt; c) { Objects.requireNonNull(c); return batchRemove(c, true);} clear()123456789101112/** * 从此列表中删除所有元素。 */public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;} 索引每一个位置设置为 null。 查询元素12345public E get(int index) { rangeCheck(index); return elementData(index);} 修改元素1234567public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;} 判断contains, indexOf,isEmpty这几个都非常简单，直接看源码，不分析了。 1234567891011121314151617181920public boolean contains(Object o) { return indexOf(o) &gt;= 0;}public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;}public boolean isEmpty() { return size == 0;} 迭代12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Iterator&lt;E&gt; iterator() { return new Itr();}private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }} 迭代器代码非常简单，不作赘述。 总结 增删改查中，增导致扩容，则会修改 modCount，删一定会修改。改和查一定不会修改 modCount。 扩容操作会导致数组复制；批量删除需要找出两个集合的交集，然后触发数组复制操作。因此，增、删都相对低效。而改、查都是很高效的操作。","link":"/2020/03/03/array-list-source-code-analysis/"},{"title":"LinkedList 源码解析","text":"LinkedList 是有序双向链表，本文分析其源码和实现原理。 定义123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList 继承了 AbstractSequentialList，实现了 List, Deque, Cloneable, Serializable 接口。 初始化要使用一个 LinkedList，首先我们要初始化它。 查看源码发现 LinkedList 有两个构造方法： 12345678910111213141516171819202122232425262728transient int size = 0;/** * 指向第一个节点的指针。 */transient Node&lt;E&gt; first;/** * 指向最后一个节点的指针。 */transient Node&lt;E&gt; last;/** * 构造一个空列表。 */public LinkedList() {}/** * 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。 * * @param c 放入此列表的元素的集合 * @throws NullPointerException 如果集合为 null */public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c);} 一个初始化完毕的空 LinkedList 拥有三个属性：第一个节点first，最后一个节点last和大小size。 另一个重载方法调用了addAll方法将集合元素添加到链表。 Node 结构Node 类保存了节点当前元素，前一个节点和下一个节点的引用。 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 常用方法解析node(int index)该方法是此类的一个重要方法，用于查找对应 index 位置的节点。如果 index 在链表前一半，则从 first 一个个向下遍历找出节点；否则从 last 一个个向前找出节点。 12345678910111213141516/** * 返回指定元素索引处的（非空）节点。 */Node&lt;E&gt; node(int index) { if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; }} 添加元素add(E e), add(int index, E element), addFirst(E e), addLast(E e)add方法是 List 接口的方法，addFirst和addLast是 Deque 接口的方法。 代码都非常简单，链接到表头或末尾时，检查相邻元素，若为 null 则此元素既是 first 又是 last。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 将指定的元素追加到此列表的末尾。和 addLast 效果相同。 * * @param e 要添加到此列表的元素 * @return true */public boolean add(E e) { linkLast(e); return true;}public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));}/** * 将指定的元素插入此列表的开头。 * * @param e 要添加到此列表的元素 */public void addFirst(E e) { linkFirst(e);}/** * 将指定的元素插入此列表的末尾。 * * @param e 要添加到此列表的元素 */public void addLast(E e) { linkLast(e);}/** * 将e链接为第一个元素。 */private void linkFirst(E e) { final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;}/** * 将e链接为最后一个元素。 */void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;}/** * 将元素e链接到非空节点succ前. */void linkBefore(E e, Node&lt;E&gt; succ) { final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;} addAll(Collection&lt;? extends E&gt; c), addAll(int index, Collection&lt;? extends E&gt; c)添加集合所有元素到列表的两个重载方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c);}public boolean addAll(int index, Collection&lt;? extends E&gt; c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true;}private void checkPositionIndex(int index) { if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}private boolean isPositionIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt;= size;} 重点看第二个重载方法，该方法大致可以分为以下几步： 检查插入位置 index 是否合法，不合法则抛出 IndexOutOfBoundsException 将集合转为数组，如果数组长度为 0 则不需要添加，返回 false 定义两个变量pred(Predecessor, 前任),succ(Successor，后任)，如果是插入到末尾，succ 为 null，pred 为 last；否则调用node(index)找到第 index 个节点赋值给 succ，succ 的前一个节点赋值给 pred 遍历 Array 中每一个元素链接到链表里 如果 succ 为 null，把 pred 赋值给 last；否则把 succ 赋值给 pred.next, pred 赋值给 succ.prev size 添加集合长度，modCount 自增，返回 true 删除元素remove(int index)根据索引删除元素 1234567891011121314151617181920212223242526272829303132333435363738394041public E remove(int index) { checkElementIndex(index); return unlink(node(index));}private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size;}/** * 取消链接非空节点x。 */E unlink(Node&lt;E&gt; x) { final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element;} 该方法也非常简单，检查 index 是否合法，然后找出对应索引节点，取消前后节点链接并把其前后重新链接起来。 remove(Object o)删除指定元素 123456789101112131415161718public boolean remove(Object o) { if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false;} 如果 o 为 null，从 first 一个个向下遍历，找到节点为 null 的节点，并调用unlink方法；否则从 first 一个个向下遍历，找到对应元素调用unlink方法。 removeFirst(), removeLast()这两个方法都非常简单，直接看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);}public E removeLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);}private E unlinkFirst(Node&lt;E&gt; f) { final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;}private E unlinkLast(Node&lt;E&gt; l) { final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;} clear()123456789101112public void clear() { for (Node&lt;E&gt; x = first; x != null; ) { Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; modCount++;} 遍历解除链表节点本身和前后引用。 其它删除方法都是类似的，不再赘述。 查询元素getFirst(), getLast()这两个操作都很高效，因为链表直接保存了第一个和最后一个节点的引用。 12345678910111213public E getFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;}public E getLast() { final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;} get(int index)随机查询效率较低，调用 node 方法进行一次二分，然后从第一个元素向后或从最后一个元素向前查找元素。 1234public E get(int index) { checkElementIndex(index); return node(index).item;} peek(), peekFirst(), peekLast()不删除的返回列表第一个(或最后一个)元素。 1234567891011121314public E peek() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;}public E peekFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;}public E peekLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;} poll(), pollFirst(), pollLast()删除并返回列表第一个(或最后一个元素) 1234567891011121314public E poll() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}public E pollFirst() { final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);}public E pollLast() { final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);} push(E e), pop()这两个方法其实就是调用了addFirst和removeFirst。 1234567public void push(E e) { addFirst(e);}public E pop() { return removeFirst();} 修改元素set(int index, E element)查询出对应 index 的节点，将节点元素替换。 1234567public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;} 判断contains, indexOf,isEmpty这几个都非常简单，直接看源码，不分析了。 12345678910111213141516171819202122232425public boolean contains(Object o) { return indexOf(o) != -1;}public int indexOf(Object o) { int index = 0; if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1;}public boolean isEmpty() { return size() == 0;} 迭代123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public ListIterator&lt;E&gt; listIterator(int index) { checkPositionIndex(index); return new ListItr(index);}private class ListItr implements ListIterator&lt;E&gt; { private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) { // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; } public boolean hasNext() { return nextIndex &lt; size; } public E next() { checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; } public boolean hasPrevious() { return nextIndex &gt; 0; } public E previous() { checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; } public int nextIndex() { return nextIndex; } public int previousIndex() { return nextIndex - 1; } public void remove() { checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; } public void set(E e) { if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; } public void add(E e) { checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; } public void forEachRemaining(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) { action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; } checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }} 迭代器的实现也不复杂，不再赘述。 总结通读了一遍 LinkedList 的源码之后不难发现与 ArrayList 相比其增删效率更高，但查找效率稍差。 LinkedList 增删元素时不需要扩容和移动数据，只需要将前后节点的引用重新链接；但查找元素时无法通过下标直接获取，而需要一个个查找，效率相比 ArrayList 自然较慢。","link":"/2020/03/06/linked-list-source-code-analysis/"},{"title":"Scala 字符串插值器","text":"Scala 提供了三种创新的字符串插值方法：s,f和raw，使用他们我们可以方便快捷的组合字符串。 用法s 字符串插值器在任何字符串前加上s，就可以直接在串中使用变量了，在生成字符串的时候会隐式调用其toString方法。 12345678910class Complex(val real: Double, val imaginary: Double) { override def toString: String = { s&quot;Complex(real=$real, imaginary=$imaginary)&quot; }}val complex = new Complex(23, -1.3)println(s&quot;$complex&quot;) 字符串插值器也可以处理任意的表达式: 1println(s&quot;1+1=${1 + 1}&quot;) f 插值器在任何字符串字面前加上f，就可以生成简单的格式化串，功能相似于其他语言中的printf函数。 类似于 Java 中的String.format 123val height = 1.9dval name = &quot;James&quot;println(f&quot;$name%s is $height%.2f meters tall&quot;) //James is 1.90 meters tall raw 插值器raw插值器可以保证其内的字符不被编码，如\\n不会被处理为回车 12println(s&quot;a\\nb&quot;) // a回车bprintln(raw&quot;a\\nb&quot;) // a\\nb 高级用法在 worksheet 中输入如下代码运行 1id&quot;string content&quot; 发现编译器提示：Error:(1, 68) value id is not a member of StringContext 即：该格式会隐式调用 StringContext 的与前缀插值器同名的方法 所以我们自定义插值器只需要这样就可以了： 123456789101112implicit class JsonHelper(val sc: StringContext) extends AnyVal { def json(args: Any*): String = { val strings = sc.parts.iterator val expressions = args.iterator var buf = new StringBuffer(strings.next) while (strings.hasNext) { buf append expressions.next buf append strings.next } parseJson(buf) }} 结语字符串插值器可以帮助我们快速格式化字符串，s会隐式调用其toString方法，f需要格式模板字符串，raw不会编码字符，我们只需要按需使用即可。","link":"/2018/06/23/scala-string-interpolation/"},{"title":"TreeMap 源码解析","text":"TreeMap 是红黑树实现的键值对容器，本文分析其源码和实现原理。 定义123public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable TreeMap 基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： 每个节点要么是黑色，要么是红色； 根节点是黑色； 每个叶子节点（NIL）是黑色； 每个红色结点的两个子结点一定都是黑色； 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 初始化TreeMap 提供了四个构造方法。 123456789101112131415161718192021222324252627282930// 比较器private final Comparator&lt;? super K&gt; comparator;// 红黑树根节点private transient Entry&lt;K,V&gt; root = null;// 集合元素数量private transient int size = 0;public TreeMap() { comparator = null;}public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator;}public TreeMap(Map&lt;? extends K, ? extends V&gt; m) { comparator = null; putAll(m);}public TreeMap(SortedMap&lt;K, ? extends V&gt; m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { }} 可以看出构造方法主要是对comparator进行了初始化，后两个方法将 Map 或 SortedMap 中的数据放入此容器中。 TreeMap 的本质是 **R-B Tree(红黑树)**，它包含几个重要的成员变量：root,size,comparator。 root是红黑树的根节点。它是 Entry 类型，Entry 是红黑数的节点，它包含了红黑数的 6 个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry 节点根据 key 进行排序，Entry 节点包含的内容为 value。 红黑数排序时，根据 Entry 中的 key 进行排序；Entry 中的 key 比较大小是根据比较器comparator来进行判断的。 size是红黑数中节点的个数。 Entry 结构TreeMap.Entry 是其节点类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static final boolean RED = false;private static final boolean BLACK = true;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; Entry(K key, V value, Entry&lt;K,V&gt; parent) { this.key = key; this.value = value; this.parent = parent; } public K getKey() { return key; } public V getValue() { return value; } public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); } public int hashCode() { int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; } public String toString() { return key + &quot;=&quot; + value; }} 该类定义了其父节点、左右子节点的引用，本身的键值以及颜色，实现了equals和hashCode方法。 常用方法解析put 方法解析put方法是 Map 最常用的方法之一，调用该方法可以添加键值对到 Map 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V put(K key, V value) { Entry&lt;K,V&gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;} 该方法可以分为以下几步： 检查根节点root，如果为 null 则初始化并赋值，然后返回；否则继续； 根据comparator或 key 对应类已经实现的Comparable的compareTo方法从root开始向下找到对应的节点位置（如果比较时相等则直接给节点的 value 赋值）； 构造 Entry，并根据比较结果插入到父节点的左或右； 调用fixAfterInsertion方法调整树结构； size和modCount自增。 以上步骤都非常简单，如果不考虑插入后的调整就是普通的二分查找树了，而红黑树和二分查找树在添加节点的最主要区别就是在fixAfterInsertion方法了。 12345678910111213141516171819202122232425262728293031323334353637383940private void fixAfterInsertion(Entry&lt;K,V&gt; x) { x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) { if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { if (x == rightOf(parentOf(x))) { x = parentOf(x); rotateLeft(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); } } else { Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { if (x == leftOf(parentOf(x))) { x = parentOf(x); rotateRight(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); } } } root.color = BLACK;} parentOf, leftof, rightOf是根据当前节点找父节点、左子节点和右子节点的方法： 1234567891011private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) { return (p == null ? null: p.parent);}private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) { return (p == null) ? null: p.left;}private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) { return (p == null) ? null: p.right;} setColor, colorOf是设置和查询节点颜色的方法： 12345678private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) { return (p == null ? BLACK : p.color);}private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) { if (p != null) p.color = c;} rotateLeft, rotateRight是左旋和右旋节点的方法： 123456789101112131415161718192021222324252627282930313233private void rotateLeft(Entry&lt;K,V&gt; p) { if (p != null) { Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; }}private void rotateRight(Entry&lt;K,V&gt; p) { if (p != null) { Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; }} 红黑树在插入节点后的调整是变色和旋转，其中旋转又分为左旋和右旋。 左旋和右旋的演示如图： 可以看出旋转虽然调整了树结构，但对每个节点而言其子节点左小右大的规则是不变的。 在红黑树里插入新节点，我们首先将新节点设置为红色，这样可以不违背定义5，减少因为黑高变化而调整的情况。 定义1，2，3都是不会冲突的，那么插入新节点可能导致的就是定义4被打破，因为新添加的节点是红色，而如果其父节点也是红色，就违背了定义4。 为方便分析，我们将祖父节点设为 G，父节点设为 P，叔叔节点设为 U，新插入的节点设为 N 添加新节点时会有以下几种情况，我们拿出 P 是一个左子节点的情况分析： 新增的是根节点，不需要处理； P 是黑色，不需要处理（新增节点 N 到根节点下也属于此情况）； P 是红色，需要调整： （1）P 和 U 都是红色，此时把 P 和 U 都变黑，然后把 G 变红，再把 G 视作新插入的节点重新调整；如果此时 G 是根节点则变黑即可； （2）P 红色，U 是黑色，此时若新插入节点是右子节点，P 左旋，变成插入左子节点的情况；如果本身就是左子节点，那么继续将 G 右旋，然后 P 变黑，G 变红即可。 若 P 为右子节点，那么镜像操作即可。 将以上情况实现为代码，就是fixAfterInsertion了。 remove 方法解析remove方法根据 key 来删除红黑树里的元素。 123456789public V remove(Object key) { Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue;} 首先调用getEntry获取对应的 Entry，getEntry方法也是查询方法的具体实现，后面再分析。 之后调用deleteEntry方法删除具体的节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Delete node p, and then rebalance the tree. */private void deleteEntry(Entry&lt;K,V&gt; p) { modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) { Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; } // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) { // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); } else if (p.parent == null) { // return if we are the only node. root = null; } else { // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) { if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; } }} 删除节点时，我们依照如下逻辑： modCount自增，size 自减； 如果被删除的节点没有子节点，直接删除； 如果被删除的节点只有一个子节点，那么删除后用子节点替代本身位置； 如果被删除的节点有两个子节点，那么找到右子树上的最小值节点，把值赋值给要被删除的节点；然后把右子树上的最小值节点视作要被删除的节点回到2或3处理； 在步骤3和4中，若删除的节点是黑色，需要调用fixAfterDeletion调整树结构。 查看上述步骤，可以发现实质上我们都是删除了只有一个子节点的节点，然后将子节点作为原节点的替代。若被删节点是红色，黑高不变；否则黑高变化需要调整树结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void fixAfterDeletion(TreeMap.Entry&lt;K,V&gt; x) { while (x != root &amp;&amp; colorOf(x) == BLACK) { if (x == leftOf(parentOf(x))) { TreeMap.Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); } if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(rightOf(sib)) == BLACK) { setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); } setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; } } else { // symmetric TreeMap.Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); } if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(leftOf(sib)) == BLACK) { setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); } setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; } } } setColor(x, BLACK);} 为方便演示，我们进行如下定义：被删节点为 N(Node) ，需要调整的替代节点为 R(Replacement)，其父节点为 P(Parent)，兄弟节点为 S(Sibling)，兄弟节点的子节点分别为 SL 和 SR，图仅演示 N 为左子节点的情况，若为右子节点镜像处理即可（R 是左子还是右子不影响）。 首先需要调整的情况下，N 一定是黑色的，若 N 是红色黑高是不变的。 若 R 为红色，将 R 变为黑色即可，此时树结构恢复平衡； R 为黑色，兄弟节点 S 是红色，此时 S 的父节点 S 和子节点 SL，SR 必然是黑色的；首先将 P 变红，S 变黑，然后左旋 P；之后可以视作 R 的兄弟节点是黑色，父节点是红色的情况进入 5 处理； R，P，S，SL 和 SR 都是黑色；我们将 S 变红，此时对 P 的父节点而言 P 子树整体黑高减1，所以需要将 P 整体视作一个替代节点重新调整； R，S 是黑色，SL 是红色，SR 是黑色；将 SL 变黑，S 变红，再右旋 S；之后我们可以进入 5 处理； R，S 是黑色，SL 是黑色，SR 是红色；互换 P 和 S 的颜色，SR 变黑，然后左旋 P；无论 P 初始时是什么颜色都能得到一个重新平衡的树。 将以上情况实现为代码，就是fixAfterDeletion了。 get 方法解析TreeMap 的get方法与二分查找树没有区别，相比起插入和删除较为简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public V get(Object key) { Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);}final Entry&lt;K,V&gt; getEntry(Object key) { // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; } return null;}final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) { @SuppressWarnings(&quot;unchecked&quot;) K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; } } return null;} 代码中若 comparator 不为 null，则使用 comparator 进行比较二分查找；否则将 key 强转为 Comparable 进行比较二分查找。 遍历TreeMap 的遍历可以通过entrySet()方法获取 EntrySet 遍历键值对；或keySet()获取 KeySet 遍历键；抑或values()获取值的集合来对值遍历。 对 EntrySet 的遍历主要是靠其 Iterator 的next,hasNext方法，先看entrySet方法： 1234public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet());} 非常简单，若有就返回，没有就构造一个返回。 其iterator方法： 1234567891011public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(getFirstEntry());}final Entry&lt;K,V&gt; getFirstEntry() { Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p;} 调用getFirstEntry方法获取 TreeMap 中 key 最小的节点，传入 EntryIterator 中初始化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntryIterator(Entry&lt;K,V&gt; first) { super(first); } public Map.Entry&lt;K,V&gt; next() { return nextEntry(); }}abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; { Entry&lt;K,V&gt; next; Entry&lt;K,V&gt; lastReturned; int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) { expectedModCount = modCount; lastReturned = null; next = first; } public final boolean hasNext() { return next != null; } final Entry&lt;K,V&gt; nextEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; } final Entry&lt;K,V&gt; prevEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; } public void remove() { if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // deleted entries are replaced by their successors if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; }} 代码非常简单，hasNext方法检查下一个节点是否为 null，next方法调用nextEntry，nextEntry中先进行合法检查，对节点为 null 和遍历过程中被修改的情况进行判断并抛出异常，再调用successor方法查找后继节点并返回。 总结TreeMap 是红黑树实现的键值对映射，使用红黑树是为了解决二分查找树可能退化为链表造成的查找效率下降，而红黑树是平衡树里调整树结构较少的一种树，达到了维护和查找的一种折中。 红黑树的调整主要依靠的是变色和旋转，在插入新节点或删除一个节点后其规则可能被打破，此时就需要调整树结构。 在分析 TreeMap 源码之前我一直把红黑树看作一只洪水猛兽不愿面对，但对其庖丁解牛一番，并且画图对照源码，发现其实并不难理解。 红黑树是一种经典的数据结构，分析了 TreeMap 的源码之后也增进了对红黑树的理解，棒棒哒。","link":"/2020/03/10/tree-map-source-code-analysis/"},{"title":"HashMap 源码解析","text":"HashMap 是散列表实现的键值对容器，本文分析其源码和实现原理。 定义12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap 基于散列表实现。 初始化HashMap 提供了四个构造方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 默认初始化容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16// 最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认加载因数static final float DEFAULT_LOAD_FACTOR = 0.75f;// 转化为树结构的阈值static final int TREEIFY_THRESHOLD = 8;// 转化为链表结构的阈值static final int UNTREEIFY_THRESHOLD = 6;// 最小树容量static final int MIN_TREEIFY_CAPACITY = 64;// hash 表transient Node&lt;K,V&gt;[] table;// map 大小transient int size;// 修改次数transient int modCount;// 阈值int threshold;// 加载因数final float loadFactor;public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);}public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);}public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR;}public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);} HashMap 的构造函数主要初始化了loadFactor加载因数和threshold扩容阈值。 tableSizeFor 原理在构造方法中的tableSizeFor方法通过传入的容量计算出大于等于给定参数 initialCapacity 最小的 2 的幂次方的数值。 123456789static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} tableSizeFor 方法的实现非常巧妙，使用了位或以及无符号右移两个操作，其步骤如下： n = cap - 1，避免因为 cap 本身就是 2 的幂次方而导致最后得到 cap * 2； n |= (n &gt;&gt;&gt; 1)，保证 n 的高 2 位是 1； n |= (n &gt;&gt;&gt; 2)，保证 n 的高 4 位是 1； n |= (n &gt;&gt;&gt; 4)，保证 n 的高 8 位是 1； n |= (n &gt;&gt;&gt; 8)，保证 n 的高 16 位是 1； n |= (n &gt;&gt;&gt; 16)，保证 n 的高 32 位是 1； 以上 2~6 步右移会保证 cap - 1 的最高 1 位之后全部被 1 填满； n &lt; 0 返回 1；n &gt;= 1 &lt;&lt; 30 返回 1 &lt;&lt; 30；否则返回 n + 1。 无论给定容量是多少，最后一步之前算出的 n 的二进制所有位都是1，最后再加1结果就是大于等于给定参数 initialCapacity 最小的 2 的幂次方的数值。 为什么要保持为 2 的幂次方？因为 HashMap 中存储数据的角标是根据数据的键的哈希值决定的，其计算方式为index = hash % table.length，如果表的大小保持为 2 的幂次方，那么可以用index = hash &amp; (table.length - 1)代替以提升效率。 Node 结构HashMap.Node 是其节点类。 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }} 该类实现了 Map.Entry，并保存了下一个节点的引用next，该类是很明显的单向链表节点。 常用方法解析hash 方法解析hash方法是 HashMap 中非常重要的方法，它调用了 key 的hashCode方法，并对其高 16 位和低 16 位进行异或操作生成新的哈希值。 这样做的目的是避免当 table 长度较小时，分配存储的 index 的时候只有低位参与，从而哈希碰撞过于频繁。 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} put 方法解析put方法是 Map 最常用的方法之一，调用该方法可以添加键值对到 Map 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;}Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);} HashMap 的 put 遵循以下步骤： table 为 null 或长度为 0 则重新计算大小； table 对应 hash 值角标的元素为 null，则构造一个 Node 放进去； 若元素 key 与新 key 相同，重新赋值 value； 若节点是一个 TreeNode，调用putTreeVal方法插入红黑树节点； 此时节点是一个链表节点，一个个向下查找对应的 key 是否存在，若存在则替换 value；否则插入新链表节点，并检查是否要转化为红黑树结构。 TreeNode 类，putTreeVal 和 treeifyBin 方法在这里就不展开了，若有相关问题可以查看《TreeMap 源码解析》这篇文章中对于红黑树结构的阐述。 由此可以看出，HashMap 是一个以数组作为基本存储，结合了链表和红黑树作为数组里的元素的键值对容器。 resize 方法这是一个 table 扩容的方法，初始化 table 或把 table 的大小增加一倍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} 该方法按以下步骤： table 未初始化则初始化，否则大小增加一倍，并计算下一次扩容阈值； 遍历旧 table，若元素没有 next，则直接放入新 table； 若是 TreeNode，调用 split 方法； 若是链表，且其 index 为 j ，遍历将每一个链表节点分配到上下半区链表，上半链表放到 table[j]，下半区链表放到 table[j + oldCap]。 resize方法因为每次扩容都是增加一倍的容量，所以每个节点新的角标会比老角标的 2 进制多一位信息，而这一位信息正好就是 hash &amp; oldCap。 若 hash &amp; oldCap 为 0，节点角标不变；否则 2 进制高位多个 1，对应的角标就添加了 oldCap。于是可以对链表节点进行拆分到 j 和 j + oldCap 两个角标。 remove 方法remove(Object key) 和 remove(Object key, Object value) 都是通过调用 removeNode 来实现删除元素的，removeNode 方法根据对应节点的结构（是树还是链表）调用不同删除逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;}@Overridepublic boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null;}final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null;} 总结HashMap 利用了类似哈希表提升了查找效率，内部使用数组，链表和红黑树保存数据。 每当保存数据超过阈值时触发扩容增加一倍容量，容量总是 2 的幂次方。 操作方法大量使用位操作提升操作效率。","link":"/2020/03/12/hash-map-source-code-analysis/"},{"title":"Retrofit 源码解析","text":"Retrofit 是流行的 Android 网络访问框架，本文基于 2.8.1 版本分析其源码，了解 Retrofit 是如何进行网络访问的。 使用方式官网文档提供了简单使用的例子： 定义接口1234public interface GitHubService { @GET(&quot;users/{user}/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);} 构建实例12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .build();GitHubService service = retrofit.create(GitHubService.class); 调用方法1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;); 分析创建 RetrofitRetrofit 的使用首先从构建 Retrofit 实例开始，使用建造者（Builder）模式链式调用创建，主要初始化了一些基础参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public static final class Builder { private final Platform platform; private @Nullable okhttp3.Call.Factory callFactory; private @Nullable HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) { this.platform = platform; } public Builder() { this(Platform.get()); } Builder(Retrofit retrofit) { platform = Platform.get(); callFactory = retrofit.callFactory; baseUrl = retrofit.baseUrl; for (int i = 1, size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize(); i &lt; size; i++) { converterFactories.add(retrofit.converterFactories.get(i)); } for (int i = 0, size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize(); i &lt; size; i++) { callAdapterFactories.add(retrofit.callAdapterFactories.get(i)); } callbackExecutor = retrofit.callbackExecutor; validateEagerly = retrofit.validateEagerly; } public Builder client(OkHttpClient client) { return callFactory(Objects.requireNonNull(client, &quot;client == null&quot;)); } public Builder callFactory(okhttp3.Call.Factory factory) { this.callFactory = Objects.requireNonNull(factory, &quot;factory == null&quot;); return this; } public Builder baseUrl(URL baseUrl) { Objects.requireNonNull(baseUrl, &quot;baseUrl == null&quot;); return baseUrl(HttpUrl.get(baseUrl.toString())); } public Builder baseUrl(String baseUrl) { Objects.requireNonNull(baseUrl, &quot;baseUrl == null&quot;); return baseUrl(HttpUrl.get(baseUrl)); } public Builder baseUrl(HttpUrl baseUrl) { Objects.requireNonNull(baseUrl, &quot;baseUrl == null&quot;); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) { throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl); } this.baseUrl = baseUrl; return this; } public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(Objects.requireNonNull(factory, &quot;factory == null&quot;)); return this; } public Builder addCallAdapterFactory(CallAdapter.Factory factory) { callAdapterFactories.add(Objects.requireNonNull(factory, &quot;factory == null&quot;)); return this; } public Builder callbackExecutor(Executor executor) { this.callbackExecutor = Objects.requireNonNull(executor, &quot;executor == null&quot;); return this; } public List&lt;CallAdapter.Factory&gt; callAdapterFactories() { return this.callAdapterFactories; } public List&lt;Converter.Factory&gt; converterFactories() { return this.converterFactories; } public Builder validateEagerly(boolean validateEagerly) { this.validateEagerly = validateEagerly; return this; } public Retrofit build() { if (baseUrl == null) { throw new IllegalStateException(&quot;Base URL required.&quot;); } okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { callFactory = new OkHttpClient(); } Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { callbackExecutor = platform.defaultCallbackExecutor(); } List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories()); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); }} 创建接口实例创建接口实例调用了 Retrofit 的 create 方法： 12345678910111213141516171819public &lt;T&gt; T create(final Class&lt;T&gt; service) { validateServiceInterface(service); return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } }); } 该方法主要使用了动态代理实现，根据接口生成对应的代理类，然后将接口的调用使用 InvocationHandler 实现。 InvocationHandler 的invoke方法就是接口生成的对应的动态代理实例方法被调用后实际上调用的地方，我们可以通过参数获取到代理对象，被调用的方法和方法参数。这里对 Object 和 Java8 之后的默认方法做了对应处理，最后走到核心代码loadServiceMethod(method).invoke(args != null ? args : emptyArgs)。 12345678910111213ServiceMethod&lt;?&gt; loadServiceMethod(Method method) { ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result;} loadServiceMethod方法优先从 serviceMethodCache 缓存中读取对应的 ServiceMethod，若没有则调用ServiceMethod.parseAnnotations生成并放入缓存，然后返回实例。 该方法内部使用了双重检查保证对应的 ServiceMethod 是单例，不会因为多线程多次生成。 12345678910111213141516171819abstract class ServiceMethod&lt;T&gt; { static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) { RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) { throw methodError(method, &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType); } if (returnType == void.class) { throw methodError(method, &quot;Service methods cannot return void.&quot;); } return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); } abstract @Nullable T invoke(Object[] args);} ServiceMethod.parseAnnotations中主要调用了RequestFactory.parseAnnotations解析代理类方法的与请求相关的注解，使用RequestFactory.Builder的建造者模式构建 RequestFactory。该类源码较长此处不展开了，具体可以参照其源码。 HttpServiceMethod.parseAnnotations方法中忽略处理 Kotlin 逻辑的代码，可以简化如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { // Kotlin suspend 函数对应逻辑 // ... } else { adapterType = method.getGenericReturnType(); } CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, &quot;'&quot; + getRawType(responseType).getName() + &quot;' is not a valid response body type. Did you mean ResponseBody?&quot;); } if (responseType == Response.class) { throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) { throw methodError(method, &quot;HEAD method must use Void as response type.&quot;); } Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { // Java 最终走到这里 return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { // 这里是 Kotlin 对应逻辑 return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory, callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter); } else { // 这里是 Kotlin 对应逻辑 return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory, callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter, continuationBodyNullable); } } 上述代码检查返回类型合法性，获取了 Retrofit 实例中的 CallAdapter.Factory 通过 get 方法创建的 CallAdapter 以及 Retrofit 实例中的 Call.Factory，然后构造了一个 CallAdapted 并返回。 调用接口方法当我们创建完毕接口实例，调用接口方法时，是调用了 HttpMethodService 的invoke方法： 123456789@Override final @Nullable ReturnT invoke(Object[] args) { Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter); return adapt(call, args);}// CallAdapted 的实现 @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) { return callAdapter.adapt(call); } 当没有设定特殊的 callAdapter 时，Retrofit.Builder 的build()方法中是这样的： 123456789101112131415161718 Builder(Retrofit retrofit) { platform = Platform.get(); // 省略其它部分 } public Retrofit build() {// 省略无关代码Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { callbackExecutor = platform.defaultCallbackExecutor(); }List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); } 而追踪 HttpServiceMethod 中的 callAdapter 的来源，最终发现其是从 retrofit 实例中的 callAdapterFactories 获取的，我们再查看 Platform 相关代码： 1234567891011121314151617181920212223class Platform { private static final Platform PLATFORM = findPlatform(); static Platform get() { return PLATFORM; } private static Platform findPlatform() { try { Class.forName(&quot;android.os.Build&quot;); if (Build.VERSION.SDK_INT != 0) { return new Android(); } } catch (ClassNotFoundException ignored) { } try { Class.forName(&quot;java.util.Optional&quot;); return new Java8(); } catch (ClassNotFoundException ignored) { } return new Platform(); }} 可以发现在 Android 上 Platform 的 get 方法返回了一个 Android 实例。 再看 Android 类的相关方法： 1234567891011121314151617181920@Override public Executor defaultCallbackExecutor() { return new MainThreadExecutor();}@Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories( @Nullable Executor callbackExecutor) { if (callbackExecutor == null) throw new AssertionError(); DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor); return Build.VERSION.SDK_INT &gt;= 24 ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory) : singletonList(executorFactory);}static class MainThreadExecutor implements Executor { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) { handler.post(r); }} 代码非常简单，defaultCallbackExecutor 获取了一个 MainThreadExecutor，该 Executor 会把操作发送给 handler 的 post 方法，让回调在 Android 主线程进行。defaultCallAdapterFactories 方法根据版本返回不同的 List，如果不考虑 定义接口时返回参数定义为 Future，那么只看 DefaultCallAdapterFactory 就可以了。 而 DefaultCallAdapterFactory 的 get 方法里实现了一个 CallAdapter 的匿名内部类： 1234567891011121314151617181920@Nullablepublic CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { if (getRawType(returnType) != Call.class) { return null; } else if (!(returnType instanceof ParameterizedType)) { throw new IllegalArgumentException(&quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;); } else { final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType)returnType); final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) ? null : this.callbackExecutor; return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() { public Type responseType() { return responseType; } public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) { return (Call)(executor == null ? call : new DefaultCallAdapterFactory.ExecutorCallbackCall(executor, call)); } }; }} 我们使用 Call 的时候都是调用 enqueue 方法，我们看看 DefaultCallAdapterFactory.ExecutorCallbackCall 的实现： 1234567891011121314151617181920212223242526272829303132333435static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; { final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) { this.callbackExecutor = callbackExecutor; this.delegate = delegate; } public void enqueue(final Callback&lt;T&gt; callback) { Utils.checkNotNull(callback, &quot;callback == null&quot;); this.delegate.enqueue(new Callback&lt;T&gt;() { public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) { ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() { public void run() { if (ExecutorCallbackCall.this.delegate.isCanceled()) { callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;)); } else { callback.onResponse(ExecutorCallbackCall.this, response); } } }); } public void onFailure(Call&lt;T&gt; call, final Throwable t) { ExecutorCallbackCall.this.callbackExecutor.execute(new Runnable() { public void run() { callback.onFailure(ExecutorCallbackCall.this, t); } }); } }); }} 本质上是调用了 delegate 的 enqueue 方法，而 delegate 是在 HttpServiceMethod 里构造出的一个 OkHttpCall，其 enqueue 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override public void enqueue(final Callback&lt;T&gt; callback) { checkNotNull(callback, &quot;callback == null&quot;); okhttp3.Call call; Throwable failure; synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already executed.&quot;); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) { try { call = rawCall = createRawCall(); } catch (Throwable t) { throwIfFatal(t); failure = creationFailure = t; } } } if (failure != null) { callback.onFailure(this, failure); return; } if (canceled) { call.cancel(); } call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response&lt;T&gt; response; try { response = parseResponse(rawResponse); } catch (Throwable e) { throwIfFatal(e); callFailure(e); return; } try { callback.onResponse(OkHttpCall.this, response); } catch (Throwable t) { throwIfFatal(t); t.printStackTrace(); // TODO this is not great } } @Override public void onFailure(okhttp3.Call call, IOException e) { callFailure(e); } private void callFailure(Throwable e) { try { callback.onFailure(OkHttpCall.this, e); } catch (Throwable t) { throwIfFatal(t); t.printStackTrace(); // TODO this is not great } } });} 最终此处交由 okhttp3.Call 来入队进行网络请求，至此 Retrofit 的一次完整的请求结束。","link":"/2020/04/01/retrofit-source-code-analysis/"},{"title":"Jetpack ViewModel 原理","text":"ViewModel 是 Architecture Components 官方架构组件之一。 ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据，它让数据可在发生屏幕旋转等配置更改后继续留存。 简单示例实现 ViewModel 123456789101112131415class MyViewModel : ViewModel() { private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy { MutableLiveData().also { loadUsers() } } fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; { return users } private fun loadUsers() { // Do an asynchronous operation to fetch users. }} 在 Activity 或 Fragment 中使用 ViewModel 1234567891011121314class MyActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { // Create a ViewModel the first time the system calls an activity's onCreate() method. // Re-created activities receive the same MyViewModel instance created by the first activity. // Use the 'by viewModels()' Kotlin property delegate // from the activity-ktx artifact val model: MyViewModel by viewModels() model.getUsers().observe(this, Observer&lt;List&lt;User&gt;&gt;{ users -&gt; // update UI }) }} 如果重新创建了该 Activity，它接收的 MyViewModel 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 ViewModel 对象的 onCleared() 方法，以便它清理资源。 ViewModel 绝不能引用视图、 Lifecycle 或可能存储对 Activity 上下文的引用的任何类。 ViewModel 妙用Fragment 与 Fragment 通信Fragment 可以使用其 Activity 范围共享 ViewModel 来处理彼此间的通信。 12345678910111213141516171819202122232425262728293031323334353637class SharedViewModel : ViewModel() { val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) { selected.value = item }}class MasterFragment : Fragment() { private lateinit var itemSelector: Selector // Use the 'by activityViewModels()' Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) itemSelector.setOnClickListener { item -&gt; // Update the UI } }}class DetailFragment : Fragment() { // Use the 'by activityViewModels()' Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) model.selected.observe(viewLifecycleOwner, Observer&lt;Item&gt; { item -&gt; // Update the UI }) }} Activity 与 Fragment 通信与 Fragment 和 Fragment 通信同理。 ViewModel 的生命周期ViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。 对 Activity，是 Activity 完成时清除；对 Fragment，时 Fragment 分离时。 ViewModel 原理从获取 ViewModel 实例的方法开始： 1val model: MyViewModel by viewModels() 或 1MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class); Kotlin 版只是对 Java 写法的一个 Lazy Delegate，所以我们从 ViewModelProvider 开始研究即可。 构造 ViewModelProvider获取 ViewModel 的入口首先构造了一个 ViewModelProvider 的实例，然后调用了其 get 方法，我们先看 ViewModelProvider 的构造函数。 12345678910111213141516171819public class ViewModelProvider { private final Factory mFactory; private final ViewModelStore mViewModelStore; public ViewModelProvider(@NonNull ViewModelStoreOwner owner) { this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance()); } public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { this(owner.getViewModelStore(), factory); } public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { mFactory = factory; mViewModelStore = store; }} 其构造函数就是初始化了两个成员 mFactory 和 mViewModelStore，它们分别是 ViewModelStoreOwner 和 ViewModelProvider.Factory 的实例。 调用构造函数时，我们传入的 AppCompatActivity 或 Fragment 都实现了 ViewModelStoreOwner 和 HasDefaultViewModelProviderFactory。 1234567891011121314151617public class AppCompatActivity extends FragmentActivity implements ... {}public class FragmentActivity extends ComponentsActivity implements ... {}public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner {}public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner {} 之后再调用 ViewModelProvider 的 get() 方法获取 ViewModel 的实例： 123456789101112131415161718192021222324252627282930public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); } return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);}public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { if (mFactory instanceof OnRequeryFactory) { ((OnRequeryFactory) mFactory).onRequery(viewModel); } return (T) viewModel; } else { //noinspection StatementWithEmptyBody if (viewModel != null) { // TODO: log a warning. } } if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); } else { viewModel = (mFactory).create(modelClass); } mViewModelStore.put(key, viewModel); return (T) viewModel;} 逻辑非常简单： 从 mViewModelStore 根据 key 获取 ViewModel 缓存; 如果 viewModel 是 modelClass 的实例，mFactory 是 OnRequeryFactory 的实例，就调用 mFactory.onRequery 重新获取 viewModel; 如果 mFactory 是 KeyedFactory 的实例，调用其 create 方法用 key 和 class 构建 ViewModel 否则直接调用 create 通过 class 构建 ViewModel 把 viewModel 放进 mViewModelStore 缓存并返回 viewModel。 ViewModelStore 和 ViewModelProvider.FactoryViewModelProvider 的三个构造函数最终都是初始化其 mFactory 和 mViewModelStore。 下面对这两个成员变量进行分析。 ViewModelStoreViewModelStore 本身是一个非常简单的类，主要作用是缓存 ViewModel。 1234567891011121314151617181920212223242526272829public class ViewModelStore { private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } } final ViewModel get(String key) { return mMap.get(key); } Set&lt;String&gt; keys() { return new HashSet&lt;&gt;(mMap.keySet()); } /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }} ComponentActivity 和 Fragment 都实现了 ViewModelStoreOwner，它是一个接口，实现它返回一个 ViewModelStore。 1234public interface ViewModelStoreOwner { @NonNull ViewModelStore getViewModelStore();} FragmentActivity 覆盖了 ComponentActivity 中的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FragmentActivitypublic ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can't request ViewModel before onCreate call.&quot;); } if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } return mViewModelStore;}static final class NonConfigurationInstances { Object custom; ViewModelStore viewModelStore; FragmentManagerNonConfig fragments;}@Overridepublic final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); if (fragments == null &amp;&amp; mViewModelStore == null &amp;&amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = mViewModelStore; nci.fragments = fragments; return nci;}@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { // ... super.onCreate(savedInstanceState); NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null &amp;&amp; nc.viewModelStore != null &amp;&amp; mViewModelStore == null) { mViewModelStore = nc.viewModelStore; } // ...} 根据 Activity 类中 onRetainNonConfigurationInstance() 的注释我们知道，该方法在配置改变时我们重建 Activity 中 destroy 原 Activity 的时候会被系统调用。而在 onCreate 方法中我们会通过 getLastNonConfigurationInstance() 获取到之前 onRetainNonConfigurationInstance() 保存的对象，由于 mViewModelStore 会被保存在 NonConfigurationInstances 中，所以旋转屏幕等配置改变的情况我们依然会获得相同的 ViewModelStore。 这个过程是由 ActivityThread 中的 performDestroyActivity 方法完成的，它会调用 Activity 的 retainNonConfigurationInstances 方法，而该方法会调用 Activity 子类的 onRetainNonConfigurationInstance() 方法作为自己的 NonConfigurationInstances.activity 保存下来。 12345678910111213141516171819202122232425262728293031323334353637383940414243static final class NonConfigurationInstances { Object activity; HashMap&lt;String, Object&gt; children; FragmentManagerNonConfig fragments; ArrayMap&lt;String, LoaderManager&gt; loaders; VoiceInteractor voiceInteractor;}@Nullablepublic Object getLastNonConfigurationInstance() { return mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.activity : null;}NonConfigurationInstances retainNonConfigurationInstances() { Object activity = onRetainNonConfigurationInstance(); HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); // We're already stopped but we've been asked to retain. // Our fragments are taken care of but we need to mark the loaders for retention. // In order to do this correctly we need to restart the loaders first before // handing them off to the next activity. mFragments.doLoaderStart(); mFragments.doLoaderStop(true); ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig(); if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null &amp;&amp; mVoiceInteractor == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) { mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; } return nci;} 重建 Activity 的时候，ActivityThread 在 performLaunchActivity 中会调用 Activity 的 attach() 方法对 mLastNonConfigurationInstances 赋值。 1234567891011final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { // ... mLastNonConfigurationInstances = lastNonConfigurationInstances; // ...} ViewModelProvider.FactoryViewModelProvider.Factory 是工厂模式的实现： 1234public interface Factory { @NonNull &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass);} HasDefaultViewModelProviderFactory 是一个接口，它主要用于标记 ViewModelStoreOwner 有一个可以提供 ViewModelFactory 的方法： 1234public interface HasDefaultViewModelProviderFactory { @NonNull ViewModelProvider.Factory getDefaultViewModelProviderFactory();} 该方法在 ComponentActivity 中的实现如下，构造了一个 SavedStateViewModelFactory。 123456789101112131415@NonNull@Overridepublic ViewModelProvider.Factory getDefaultViewModelProviderFactory() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can't request ViewModel before onCreate call.&quot;); } if (mDefaultFactory == null) { mDefaultFactory = new SavedStateViewModelFactory( getApplication(), this, getIntent() != null ? getIntent().getExtras() : null); } return mDefaultFactory;} 而 SavedStateViewModelFactory 继承自 ViewModelProvider.KeyedFactory 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final class SavedStateViewModelFactory extends ViewModelProvider.KeyedFactory { private final Application mApplication; private final ViewModelProvider.AndroidViewModelFactory mFactory; private final Bundle mDefaultArgs; private final Lifecycle mLifecycle; private final SavedStateRegistry mSavedStateRegistry; public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs) { mSavedStateRegistry = owner.getSavedStateRegistry(); mLifecycle = owner.getLifecycle(); mDefaultArgs = defaultArgs; mApplication = application; mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); } @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) { constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); } else { constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); } // doesn't need SavedStateHandle if (constructor == null) { return mFactory.create(modelClass); } SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); try { T viewmodel; if (isAndroidViewModel) { viewmodel = constructor.newInstance(mApplication, controller.getHandle()); } else { viewmodel = constructor.newInstance(controller.getHandle()); } viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; } catch (IllegalAccessException e) { throw new RuntimeException(&quot;Failed to access &quot; + modelClass, e); } catch (InstantiationException e) { throw new RuntimeException(&quot;A &quot; + modelClass + &quot; cannot be instantiated.&quot;, e); } catch (InvocationTargetException e) { throw new RuntimeException(&quot;An exception happened in constructor of &quot; + modelClass, e.getCause()); } } @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); } return create(canonicalName, modelClass); }} 通过前面的分析我们知道 ViewModelProvider 的 mFactory 是 KeyedFactory 的实例时，会调用其两个参数的 create() 方法创建 ViewModel。该方法通过传入的 class 检查是 AndroidViewModel 还是普通 ViewModel 的实例，然后构造对应的实例。 SavedStateViewModelFactory 的作用主要是用于创建可以保存当前页面的数据的 ViewModel。也就是说当我们的页面数据还是保存在页面的时候，我们可以通过该默认工厂，把页面的数据存储到由 SavedStateViewModelFactory 所创建的 ViewModel 中进行保存。 前提是：需要我们的 ViewModel 的最终实现类的构造方法签名和下面的 ANDROID_VIEWMODEL_SIGNATURE 或 VIEWMODEL_SIGNATURE 一样才会起到上面说的效果： 1234567class SaveStateViewModel(val savedStateHandle: SavedStateHandle) : ViewModel() {}private static final Class&lt;?&gt;[] ANDROID_VIEWMODEL_SIGNATURE = new Class[]{Application.class, SavedStateHandle.class};private static final Class&lt;?&gt;[] VIEWMODEL_SIGNATURE = new Class[]{SavedStateHandle.class}; 否则，就会调用 ViewModelProvider.AndroidViewModelFactory 中的 create() 方法去创建 ViewModel 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory { private static AndroidViewModelFactory sInstance; /** * Retrieve a singleton instance of AndroidViewModelFactory. * * @param application an application to pass in {@link AndroidViewModel} * @return A valid {@link AndroidViewModelFactory} */ @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) { if (sInstance == null) { sInstance = new AndroidViewModelFactory(application); } return sInstance; } private Application mApplication; /** * Creates a {@code AndroidViewModelFactory} * * @param application an application to pass in {@link AndroidViewModel} */ public AndroidViewModelFactory(@NonNull Application application) { mApplication = application; } @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) { if (AndroidViewModel.class.isAssignableFrom(modelClass)) { //noinspection TryWithIdenticalCatches try { return modelClass.getConstructor(Application.class).newInstance(mApplication); } catch (NoSuchMethodException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (IllegalAccessException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (InstantiationException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (InvocationTargetException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } } return super.create(modelClass); }} ViewModel.onCleared()ViewModel 同时提供了一个清理资源的方法 onCleared()，那么它是什么时候被调用的呢？ 123456789101112131415161718public abstract class ViewModel { protected void onCleared() { } @MainThread final void clear() { mCleared = true; if (mBagOfTags != null) { synchronized (mBagOfTags) { for (Object value : mBagOfTags.values()) { // see comment for the similar call in setTagIfAbsent closeWithRuntimeException(value); } } } onCleared(); }} 很明显它在 clear() 方法中被调用。 而 ViewModel 的 clear() 则是被 ViewModelStore 的 clear() 调用： 1234567891011public class ViewModelStore { private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }} 追踪该方法发现它在 ComponentActivity 的默认构造中被调用： 1234567891011121314151617181920212223public ComponentActivity() { Lifecycle lifecycle = getLifecycle(); //noinspection ConstantConditions if (lifecycle == null) { throw new IllegalStateException(&quot;getLifecycle() returned null in ComponentActivity's &quot; + &quot;constructor. Please make sure you are lazily constructing your Lifecycle &quot; + &quot;in the first call to getLifecycle() rather than relying on field &quot; + &quot;initialization.&quot;); } // ... getLifecycle().addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_DESTROY) { if (!isChangingConfigurations()) { getViewModelStore().clear(); } } } }); // ...} 非常明显就是对生命周期进行了监听，在 Lifecycle.Event.ON_DESTROY 被触发的时候调用，清理资源。 ViewModel 高级使用AndroidViewModelAndroidViewModel 是 ViewModel 的一个子类，它可以在 ViewModel 中获取 Application。 123456789101112131415161718public class AndroidViewModel extends ViewModel { @SuppressLint(&quot;StaticFieldLeak&quot;) private Application mApplication; public AndroidViewModel(@NonNull Application application) { mApplication = application; } /** * Return the application. */ @SuppressWarnings(&quot;TypeParameterUnusedInFormals&quot;) @NonNull public &lt;T extends Application&gt; T getApplication() { //noinspection unchecked return (T) mApplication; }} 我们使用时只需要继承它然后实现对应的构造函数即可。 保存状态我们分析源码时发现当 ViewModel 的构造函数满足如下两种情况时： 123private static final Class&lt;?&gt;[] ANDROID_VIEWMODEL_SIGNATURE = new Class[]{Application.class, SavedStateHandle.class};private static final Class&lt;?&gt;[] VIEWMODEL_SIGNATURE = new Class[]{SavedStateHandle.class}; 它会调用对应的构造方法来创建 ViewModel： 12345678910111213141516171819SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs);try { T viewmodel; if (isAndroidViewModel) { viewmodel = constructor.newInstance(mApplication, controller.getHandle()); } else { viewmodel = constructor.newInstance(controller.getHandle()); } viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel;} catch (IllegalAccessException e) { throw new RuntimeException(&quot;Failed to access &quot; + modelClass, e);} catch (InstantiationException e) { throw new RuntimeException(&quot;A &quot; + modelClass + &quot; cannot be instantiated.&quot;, e);} catch (InvocationTargetException e) { throw new RuntimeException(&quot;An exception happened in constructor of &quot; + modelClass, e.getCause());} ViewModel 构造器加入 SavedStateHandle 参数，并将想要保存的数据使用该 handle 保存。 123class SaveStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() { val liveDataText: LiveData&lt;TestModel&gt; = savedStateHandle.getLiveData(LIVE_DATE_KEY)} 总结ViewModel 是一个非常方便使用的 Jetpack 架构组件，但小小的一个类却包含了非常精细巧妙的设计，非常值得学习。","link":"/2020/06/17/jetpack-viewmodel/"},{"title":"Glide 源码解析","text":"Glide 是一个非常优秀的图片加载框架，为我们处理了图片加载中的各种痛点，如：多种尺寸格式的缓存、生命周期感知、高效处理 Bitmap 等，本文解析其源码分析它是如何做到这些的。 使用方法以官网文档为例，一个最简单的使用方法： 123Glide.with(fragment) .load(url) .into(imageView); 大多数情况我们直接如上调用即可。该使用方式可以简单分为三步： with(context) load(url) into(target) 以上的 with 也可以传入 Activity 或 Fragment，load 也可以传入图片 drawableId 等。 分析with 系列方法Glide 的 with 方法共有五个常用的重载方法： 123456789101112131415161718192021222324@NonNullpublic static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context);}@NonNullpublic static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity);}@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).get(activity);}@NonNullpublic static RequestManager with(@NonNull Fragment fragment) { return getRetriever(fragment.getContext()).get(fragment);}@NonNullpublic static RequestManager with(@NonNull View view) { return getRetriever(view.getContext()).get(view);} 以上五个方法都调用了 getRetriver 方法，传入了 context： 1234567891011@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) { // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot; + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot; + &quot;is attached or after the Fragment is destroyed).&quot;); return Glide.get(context).getRequestManagerRetriever();} 该方法返回了一个 RequestManagerRetriever 对象，Glide.get(context).getRequestManagerRetriever();的具体实现： 123456789101112131415161718192021private static volatile Glide glide;/** * Get the singleton. * * @return the singleton */@NonNullpublic static Glide get(@NonNull Context context) { if (glide == null) { GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(context.getApplicationContext()); synchronized (Glide.class) { if (glide == null) { checkAndInitializeGlide(context, annotationGeneratedModule); } } } return glide;} Glide.get()是一个懒汉式初始化 Glide 单例的方法，checkAndInitializeGlide这个方法就不进去具体分析了，里面主要是进行了一些组件如 Log 和 GlideModule 的初始化。 getRequestManagerRetriever方法实际上获取了一个 new 出来的 RequestManagerRetriever，我们直接看看 RequestManagerRetriever.get(context) 的源码： 1234567891011121314151617@NonNullpublic RequestManager get(@NonNull Context context) { if (context == null) { throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;); } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) { if (context instanceof FragmentActivity) { return get((FragmentActivity) context); } else if (context instanceof Activity) { return get((Activity) context); } else if (context instanceof ContextWrapper &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) { return get(((ContextWrapper) context).getBaseContext()); } } return getApplicationManager(context);} 以上方法根据传入的 context 的类型不同采取不同操作，以getApplicationManager(context)分析： 123456789101112131415161718@NonNull private RequestManager getApplicationManager(@NonNull Context context) { if (applicationManager == null) { synchronized (this) { if (applicationManager == null) { Glide glide = Glide.get(context.getApplicationContext()); applicationManager = factory.build( glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode(), context.getApplicationContext()); } } } return applicationManager; } 此处显然是一个懒汉式创建 applicationManager 单例的方法，若传入的是 FragmentActivity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@NonNullpublic RequestManager get(@NonNull FragmentActivity activity) { if (Util.isOnBackgroundThread()) { return get(activity.getApplicationContext()); } else { assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet(activity, fm, null, isActivityVisible(activity)); }}@NonNullprivate RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) { Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); } return requestManager;}@NonNullprivate SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) { current = pendingSupportRequestManagerFragments.get(fm); if (current == null) { current = new SupportRequestManagerFragment(); current.setParentFragmentHint(parentHint); if (isParentVisible) { current.getGlideLifecycle().onStart(); } pendingSupportRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget(); } } return current;} 如果不在主线程则调用get方法传入 applicationContext，最终会走到getApplicationManager。否则生成一个没有界面的 fragment 并 add 到 FragmentActivity 中，然后返回已存在的或新构造的 RequestManager。 fragment 对应的也类似，就不再分析了。 load 系列方法通过 with 系列方法我们拿到了一个 RequestManager，然后我们会调用 RequestManager 的 load 系列方法，RequestManager 中有多个重载方法，我们以load(String)为例分析： 123456@NonNull@CheckResult@Overridepublic RequestBuilder&lt;Drawable&gt; load(@Nullable String string) { return asDrawable().load(string);} 首先看看asDrawable()方法： 123456789101112@NonNull@CheckResultpublic RequestBuilder&lt;Drawable&gt; asDrawable() { return as(Drawable.class);}@NonNull@CheckResultpublic &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as( @NonNull Class&lt;ResourceType&gt; resourceClass) { return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);} 本质上是构造了一个加载 Drawable 的 RequestBuilder。然后看看RequestBuilder.load(string)方法： 12345678910111213@NonNull@Override@CheckResultpublic RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) { return loadGeneric(string);}@NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) { this.model = model; isModelSet = true; return this;} 非常简单，就是设置了 model 和 isModelSet 两个变量。 into 方法into 方法设置 ImageView 12345678910111213141516171819202122232425262728293031323334353637@NonNullpublic ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) { Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&lt;?&gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) { switch (view.getScaleType()) { case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. } } return into( glideContext.buildImageViewTarget(view, transcodeClass), null, requestOptions, Executors.mainThreadExecutor());} 该方法检查了是否是在主线程进行调用，以及传入的 view 是否为 null，之后获取 ImageView 的 ScaleType 设置到 requestOptions 中，然后把 ImageView 传入glideContext.buildImageViewTarget(view, transcodeClass)中包装成一个 Target 对象，再调用重载的 into 方法： 123456789101112131415161718192021222324252627282930313233343536@NonNull@Synthetic&lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, Executor callbackExecutor) { return into(target, targetListener, this, callbackExecutor);}private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options, Executor callbackExecutor) { Preconditions.checkNotNull(target); if (!isModelSet) { throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;); } Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); if (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { if (!Preconditions.checkNotNull(previous).isRunning()) { previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target;} buildRequest(target, targetListener, options, callbackExecutor);根据传入的数据构造了一个 Request 对象，如果有正在进行中的请求且和新的相同，则开始之前的；否则清除 target 的请求再设置新的 request。 target.getRequest()和target.setRequest()在 ViewTarget 中的实现如下： 123456789101112131415161718192021222324252627282930@Override@Nullablepublic Request getRequest() { Object tag = getTag(); Request request = null; if (tag != null) { if (tag instanceof Request) { request = (Request) tag; } else { throw new IllegalArgumentException( &quot;You must not call setTag() on a view Glide is targeting&quot;); } } return request;}@Nullableprivate Object getTag() { return view.getTag(tagId);}@Overridepublic void setRequest(@Nullable Request request) { setTag(request);}private void setTag(@Nullable Object tag) { isTagUsedAtLeastOnce = true; view.setTag(tagId, tag);} 可以看到实际上是把 Request 作为 View 的 tag，然后重点观察以下这几句代码： 123456789101112Request previous = target.getRequest(); if (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { if (!Preconditions.checkNotNull(previous).isRunning()) { previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); 以上的执行逻辑如下： 获取 target 之前的 request 如果新的 request 和之前的 request 逻辑相等，且非（跳过内存缓存且前一个请求已结束），且前一个请求未在运行，就重新开始前一个请求； 否则清除 target 的 request，并重新设置 request，再调用requestManager.track(target, request);开始请求。 从上述逻辑可以看出这样的方式可以解决 ListView 和 RecyclerView 中加载图片错位的问题。 requestManager.track(target, request)源码如下： 1234synchronized void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) { targetTracker.track(target); requestTracker.runRequest(request);} 这是一个同步方法，保证了同一时间只有一个线程调用到这里，targetTracker.track(target)是一个观察者模式的实现，TargetTracker 实现了 LifecycleListener 且注册了 target，然后会根据生命周期调用其方法，这也是 Glide 可以感知生命周期结束加载图片的原理。 requestTracker.runRequest(request)实现如下： 123456789101112public void runRequest(@NonNull Request request) { requests.add(request); if (!isPaused) { request.begin(); } else { request.clear(); if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, &quot;Paused, delaying request&quot;); } pendingRequests.add(request); }} 调用了request.begin()，这里通常都是 SingleRequest，我们看一下 SingleRequest 的 begin 方法的实现： 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void begin() { synchronized (requestLock) { // ...省略部分代码 if (model == null) { // ...省略部分代码 int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG; onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel); return; } if (status == Status.RUNNING) { throw new IllegalArgumentException(&quot;Cannot restart a running request&quot;); } if (status == Status.COMPLETE) { onResourceReady(resource, DataSource.MEMORY_CACHE); return; } status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) { onSizeReady(overrideWidth, overrideHeight); } else { target.getSize(this); } if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) &amp;&amp; canNotifyStatusChanged()) { target.onLoadStarted(getPlaceholderDrawable()); } // ... }} 这里会走到status = Status.WAITING_FOR_SIZE;如果有设置合法的 overrideWidth 和 overrideHeight，就调用onSizeReady(overrideWidth, overrideHeight)否则调用target.getSize(this)` 获取尺寸，然后回调 onSizeReady。 onSizeReady 中会调用 engine.load 方法，这是 Glide 加载图片的核心方法，在该方法中加载完毕之后会回调 SingleRequest 的 onResourceReady 方法，再对资源进行一些加载完毕的回调。 Engine 的 load 方法1234567891011121314151617181920212223242526272829303132333435363738public &lt;R&gt; LoadStatus load(...) { // .. 省略部分代码synchronized (this) { // 从内存缓存中读取 memoryResource = loadFromMemory(key, isMemoryCacheable, startTime); if (memoryResource == null) { return waitForExistingOrStartNewJob(...); } // 这里会回调 onResourceReady cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE); return null;}private &lt;R&gt; LoadStatus waitForExistingOrStartNewJob(...) { EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache); if (current != null) { current.addCallback(cb, callbackExecutor); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key); } return new LoadStatus(cb, current); } // 省略部分参数 EngineJob&lt;R&gt; engineJob = engineJobFactory.build(...); DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(...); jobs.put(key, engineJob); engineJob.addCallback(cb, callbackExecutor); engineJob.start(decodeJob); if (VERBOSE_IS_LOGGABLE) { logWithTimeAndKey(&quot;Started new load&quot;, startTime, key); } return new LoadStatus(cb, engineJob);} 最终通过engineJob.start(devodeJob)方法执行： 123456public synchronized void start(DecodeJob&lt;R&gt; decodeJob) { this.decodeJob = decodeJob; GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor(); executor.execute(decodeJob);} 在图片加载完毕之后会调用回调 onResourceReady，我们再回归 SingleRequest 的 onResourceReady 方法： 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) { stateVerifier.throwIfRecycled(); Resource&lt;?&gt; toRelease = null; try { synchronized (requestLock) { // 省略部分代码 onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource); } } finally { if (toRelease != null) { engine.release(toRelease); } }}@GuardedBy(&quot;requestLock&quot;)private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) { // We must call isFirstReadyResource before setting status. boolean isFirstResource = isFirstReadyResource(); status = Status.COMPLETE; this.resource = resource; isCallingCallbacks = true; try { // 省略部分代码 anyListenerHandledUpdatingTarget |= targetListener != null &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource); if (!anyListenerHandledUpdatingTarget) { Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource); target.onResourceReady(result, animation); } } finally { isCallingCallbacks = false; } notifyLoadSuccess();} 可以看出最终是走到了target.onResourceReady(result, animation)，看看在 ImageViewTarget 中的实现： 123456789101112131415 @Override public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) { if (transition == null || !transition.transition(resource, this)) { setResourceInternal(resource); } else { maybeUpdateAnimatable(resource); } } private void setResourceInternal(@Nullable Z resource) { setResource(resource); maybeUpdateAnimatable(resource); }protected abstract void setResource(@Nullable Z resource); 最终会调用setResource方法，而这个方法是一个抽象方法，是由子类实现的，而 ImageViewTarget 有三个子类，最常见的是 DrawableImageViewTarget，它的实现如下： 1234@Overrideprotected void setResource(@Nullable Drawable resource) { view.setImageDrawable(resource);} 非常简单就是直接调用了 ImageView 的 setImageDrawable 方法，至此一次完整的图片加载结束。","link":"/2020/04/08/glide-source-code-analysis/"},{"title":"Jetpack SavedState 原理","text":"Android 的 Activity 有着一套 onSaveInstanceState - onRestoreInstanceState 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验。 在 androidx 下，提供了 SavedState 库帮助 Activity 和 Fragment 处理状态保存和恢复。 使用 SavedState可以显式引入 SavedState 库 1implementation &quot;androidx.savedstate:savedstate:1.0.0&quot; 但实际上 appcompat 会引入 activity 的依赖，而 activity 会自动引入 savedstate。 SavedState 组件SavedState 是一个非常小的库，总共由四个 class 文件组成。 SavedStateRegistry.SavedStateProvider用于标记一个组件需要保存状态，该状态会在以后恢复的时候使用。 1234public interface SavedStateProvider { @NonNull Bundle saveState();} SavedStateRegistry管理 SavedStateProvider 的组件，它绑定了其所有者的生命周期（ Activity 或 Fragment）。 每次创建生命周期所有者都会创建一个新的实例 创建注册表的所有者后（例如，在调用 Activity 的 onCreate(savedInstanceState) 方法之后），将调用其 performRestore(state) 方法，以恢复系统杀死其所有者之前保存的任何状态。 1234567void performRestore(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState) { // ... if (savedState != null) { mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY); } // ...} 每个 SavedStateProvider 都会注册自己的唯一 Key 123456789101112private SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = new SafeIterableMap&lt;&gt;();public void registerSavedStateProvider(@NonNull String key, @NonNull SavedStateProvider provider) { SavedStateProvider previous = mComponents.putIfAbsent(key, provider); if (previous != null) { throw new IllegalArgumentException(&quot;SavedStateProvider with the given key is already registered&quot;); }}public void unregisterSavedStateProvider(@NonNull String key) { mComponents.remove(key);} 一旦完成注册，就可以通过 consumeRestoredStateForKey(key) 获取之前保存的状态。 在 Activity 的 onSaveInstanceState() 被调用时，SavedStateRegistry 的 performSave(outBundle) 会调用每个已注册的 SavedStateProvider 的 saveState() 来保存状态。 123456789101112void performSave(@NonNull Bundle outBundle) { Bundle components = new Bundle(); if (mRestoredState != null) { components.putAll(mRestoredState); } for (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) { Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next(); components.putBundle(entry1.getKey(), entry1.getValue().saveState()); } outBundle.putBundle(SAVED_COMPONENTS_KEY, components);} SavedStateRegistryControllerSavedStateRegistry 的控制器，对 SavedStateRegistry 的两个方法进行了封装，屏蔽了 SavedStateRegistry 的一些细节： 12345678910111213public final class SavedStateRegistryController { private final SavedStateRegistryOwner mOwner; private final SavedStateRegistry mRegistry; public void performRestore(@Nullable Bundle savedState) { // ... mRegistry.performRestore(lifecycle, savedState); } public void performSave(@NonNull Bundle outBundle) { mRegistry.performSave(outBundle); }} SavedStateRegistryOwner定义了一个 SavedStateRegistry 持有者的接口，提供了一个获取 SavedStateRegistry 的方法。ComponentActivity 和 Fragment 都已经实现了该接口。 1234public interface SavedStateRegistryOwner extends LifecycleOwner { @NonNull SavedStateRegistry getSavedStateRegistry();} SavedState 组件关系 Activity 状态保存Activity 的状态保存分为 View 状态和成员状态 默认情况下，系统使用 Bundle 实例状态来保存有关 Activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 Recyclerview 的滚动位置）。 因此，如果 Activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（注意，需要恢复状态的 view 需要配置 id ） 这部分逻辑在 Activity 中的 onSaveInstanceState 方法内实现 1234567891011121314protected void onSaveInstanceState(@NonNull Bundle outState) { outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); Parcelable p = mFragments.saveAllState(); if (p != null) { outState.putParcelable(FRAGMENTS_TAG, p); } if (mAutoFillResetNeeded) { outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); } dispatchActivitySaveInstanceState(outState);} ComponentActivity 实现了 SavedStateRegistryOwner，它的相关源码如下： 1234567891011121314151617181920212223242526public class ComponentActivity extends androidx.core.app.ComponentActivity implements SavedStateRegistryOwner { private final SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); // ... } @Override protected void onSaveInstanceState(@NonNull Bundle outState) { // ... //这里先调用父类的 onSaveInstanceState 保存 view 状态 super.onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); } @NonNull @Override public final SavedStateRegistry getSavedStateRegistry() { return mSavedStateRegistryController.getSavedStateRegistry(); }} ComponentActivity 持有 SavedStateRegistryController 的实例 mSavedStateRegistryController，在 onCreate 生命周期方法中调用 controller 的 performRestore 查询已保存的状态，在 onSaveInstanceState 中调用 controller 的 performSave 保存。 FragmentActivity 在 onSaveInstanceState 中还会对其内部的 fragment 的状态保存，并在 onCreate 中恢复。 123456789101112131415161718192021222324252627final FragmentController mFragments = FragmentController.createController(new HostCallbacks());@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); // ... if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreSaveState(p); // ... } // ...}@Overrideprotected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); markFragmentsCreated(); Parcelable p = mFragments.saveAllState(); if (p != null) { outState.putParcelable(FRAGMENTS_TAG, p); } // ...} Fragment 状态保存androidx 的 Fragment 使用 FragmentManager 处理 Fragment 的状态保存。 Activity 中调用 FragmentController 的 saveAllState() 方法，间接调用 FragmentManager 的实现类 FragmentManagerImpl 的 saveAllState()。 12345678910111213141516171819202122232425262728293031Parcelable saveAllState() { // ... mStateSaved = true; // 收集 Active Fragment ArrayList&lt;FragmentState&gt; active = mFragmentStore.saveActiveFragments(); if (active.isEmpty()) { if (isLoggingEnabled(Log.VERBOSE)) Log.v(TAG, &quot;saveAllState: no fragments!&quot;); return null; } // 构建一个 Added Fragment 的 List ArrayList&lt;String&gt; added = mFragmentStore.saveAddedFragments(); // 保存回退栈 BackStackState[] backStack = null; if (mBackStack != null) { // 省略保存操作 } FragmentManagerState fms = new FragmentManagerState(); fms.mActive = active; fms.mAdded = added; fms.mBackStack = backStack; fms.mBackStackIndex = mBackStackIndex.get(); if (mPrimaryNav != null) { fms.mPrimaryNavActiveWho = mPrimaryNav.mWho; } return fms;} 其中最重要的是 mFragmentStore.saveActiveFragments()，收集 Active 状态的 Fragment 信息。 1234567891011121314151617@NonNullArrayList&lt;FragmentState&gt; saveActiveFragments() { ArrayList&lt;FragmentState&gt; active = new ArrayList&lt;&gt;(mActive.size()); for (FragmentStateManager fragmentStateManager : mActive.values()) { if (fragmentStateManager != null) { Fragment f = fragmentStateManager.getFragment(); FragmentState fs = fragmentStateManager.saveState(); active.add(fs); if (FragmentManager.isLoggingEnabled(Log.VERBOSE)) { Log.v(TAG, &quot;Saved state of &quot; + f + &quot;: &quot; + fs.mSavedFragmentState); } } } return active;} 它最终是调用了 FragmentStateManager 的 saveState() 方法保存状态。 123456789101112131415161718192021222324252627282930313233343536@NonNullFragmentState saveState() { FragmentState fs = new FragmentState(mFragment); if (mFragment.mState &gt; Fragment.INITIALIZING &amp;&amp; fs.mSavedFragmentState == null) { fs.mSavedFragmentState = saveBasicState(); // ... } else { fs.mSavedFragmentState = mFragment.mSavedFragmentState; } return fs;}private Bundle saveBasicState() { Bundle result = new Bundle(); mFragment.performSaveInstanceState(result); // ... if (mFragment.mView != null) { saveViewState(); } // ... return result;}void saveViewState() { if (mFragment.mView == null) { return; } SparseArray&lt;Parcelable&gt; mStateArray = new SparseArray&lt;&gt;(); mFragment.mView.saveHierarchyState(mStateArray); if (mStateArray.size() &gt; 0) { mFragment.mSavedViewState = mStateArray; }} Fragment 的状态保存可以大致分为以下几步： saveState saveBasicState Fragment.performSaveInstanceState saveViewState 而在 Fragment 的 performSaveInstanceState 方法中，会调用 SavedStateRegistryController.performSave(outState) 保存自身状态。 然后调用 mChildFragmentManager 的 saveAllState() 方法保存子 Fragment 状态。 12345678void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); Parcelable p = mChildFragmentManager.saveAllState(); if (p != null) { outState.putParcelable(FragmentActivity.FRAGMENTS_TAG, p); }} Fragment 的 onCreate 方法中会调用 restoreChildFragmentState 恢复子 Fragment 状态。 123456789101112131415161718public void onCreate(@Nullable Bundle savedInstanceState) { mCalled = true; restoreChildFragmentState(savedInstanceState); if (!mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) { mChildFragmentManager.dispatchCreate(); }}void restoreChildFragmentState(@Nullable Bundle savedInstanceState) { if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable( FragmentActivity.FRAGMENTS_TAG); if (p != null) { mChildFragmentManager.restoreSaveState(p); mChildFragmentManager.dispatchCreate(); } }} ViewModel-SavedStateJetpack 中使用 MVVM 模式时，UI 的状态通常被 ViewModel 持有并存储。ViewModel-SavedState 就是一个使得使用 ViewModel 时可以非常方便的恢复状态的库。 使用该库时，ViewModel 对象需要有一个参数为 SavedStateHandle 的构造方法，然后在其初始化方法中恢复数据。 ViewModel-SavedState 组件SavedStateHandle可以把 saved state 传递给 ViewModel 的类，内部持有保存状态的键值对数据。 这是在 ViewModel 中主要使用的类，我们通常会如下使用它： 123class SaveStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() { val liveDataText: LiveData&lt;TestModel&gt; = savedStateHandle.getLiveData(LIVE_DATE_KEY)} 在调用其 getLiveData() 方法的时候，我们就会把该 LiveData 根据 key 存入对应的 map。 1234567891011121314151617181920212223242526272829303132public final class SavedStateHandle { final Map&lt;String, Object&gt; mRegular; private final Map&lt;String, SavingStateLiveData&lt;?&gt;&gt; mLiveDatas = new HashMap&lt;&gt;(); @NonNull public &lt;T&gt; MutableLiveData&lt;T&gt; getLiveData(@NonNull String key, @SuppressLint(&quot;UnknownNullness&quot;) T initialValue) { return getLiveDataInternal(key, true, initialValue); } @NonNull private &lt;T&gt; MutableLiveData&lt;T&gt; getLiveDataInternal( @NonNull String key, boolean hasInitialValue, @Nullable T initialValue) { MutableLiveData&lt;T&gt; liveData = (MutableLiveData&lt;T&gt;) mLiveDatas.get(key); if (liveData != null) { return liveData; } SavingStateLiveData&lt;T&gt; mutableLd; // double hashing but null is valid value if (mRegular.containsKey(key)) { mutableLd = new SavingStateLiveData&lt;&gt;(this, key, (T) mRegular.get(key)); } else if (hasInitialValue) { mutableLd = new SavingStateLiveData&lt;&gt;(this, key, initialValue); } else { mutableLd = new SavingStateLiveData&lt;&gt;(this, key); } mLiveDatas.put(key, mutableLd); return mutableLd; }} 被 SavedStateHandle 持有的 mSavedStateProvider 实现了其数据保存逻辑，把 mRegular 中的数据遍历保存。 1234567891011121314151617181920private final SavedStateProvider mSavedStateProvider = new SavedStateProvider() { @SuppressWarnings(&quot;unchecked&quot;) @NonNull @Override public Bundle saveState() { Set&lt;String&gt; keySet = mRegular.keySet(); ArrayList keys = new ArrayList(keySet.size()); ArrayList value = new ArrayList(keys.size()); for (String key : keySet) { keys.add(key); value.add(mRegular.get(key)); } Bundle res = new Bundle(); // &quot;parcelable&quot; arraylists - lol res.putParcelableArrayList(&quot;keys&quot;, keys); res.putParcelableArrayList(&quot;values&quot;, value); return res; }}; 而 mLiveDatas 保存的 SavingStateLiveData，在其内部值变化的时候都会存入 mRegular 中： 12345678910111213141516171819202122232425262728static class SavingStateLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; { private String mKey; private SavedStateHandle mHandle; SavingStateLiveData(SavedStateHandle handle, String key, T value) { super(value); mKey = key; mHandle = handle; } SavingStateLiveData(SavedStateHandle handle, String key) { super(); mKey = key; mHandle = handle; } @Override public void setValue(T value) { if (mHandle != null) { mHandle.mRegular.put(mKey, value); } super.setValue(value); } void detach() { mHandle = null; }} 除了 getLiveData，我们也可以使用 set 和 get 方法保存或恢复数据。 123456789101112131415public &lt;T&gt; void set(@NonNull String key, @Nullable T value) { validateValue(value); @SuppressWarnings(&quot;unchecked&quot;) MutableLiveData&lt;T&gt; mutableLiveData = (MutableLiveData&lt;T&gt;) mLiveDatas.get(key); if (mutableLiveData != null) { // it will set value; mutableLiveData.setValue(value); } else { mRegular.put(key, value); }}public &lt;T&gt; T get(@NonNull String key) { return (T) mRegular.get(key);} SavedStateHandleController实现了 LifecycleEventObserver 的类，在创建的的时候从 SavedStateRegistry 中恢复状态到 SavedStateHandle，再调用 attachToLifecycle 把持有的 SavedStateHandle 内部的 SavedStateProvider 注册到 SavedStateRegistry 中。 1234567891011121314151617181920final class SavedStateHandleController implements LifecycleEventObserver { private final SavedStateHandle mHandle; void attachToLifecycle(SavedStateRegistry registry, Lifecycle lifecycle) { // ... lifecycle.addObserver(this); registry.registerSavedStateProvider(mKey, mHandle.savedStateProvider()); } static SavedStateHandleController create(SavedStateRegistry registry, Lifecycle lifecycle, String key, Bundle defaultArgs) { Bundle restoredState = registry.consumeRestoredStateForKey(key); SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, defaultArgs); SavedStateHandleController controller = new SavedStateHandleController(key, handle); controller.attachToLifecycle(registry, lifecycle); tryToAddRecreator(registry, lifecycle); return controller; }} AbstractSavedStateViewModelFactory一个实现 ViewModelFactory.KeyedFactory 的 ViewModel Factory ，它会创建一个与实例化的请求的 ViewModel 关联的SavedStateHandle 12345678910111213141516171819202122232425public abstract class AbstractSavedStateViewModelFactory extends ViewModelProvider.KeyedFactory { private final SavedStateRegistry mSavedStateRegistry; // Default state used when the saved state is empty private final Bundle mDefaultArgs; @Override public final &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { // 读取保存的状态 Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key); // 创建保存状态的 handle SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs); // ... // 创建 viewModel T viewmodel = create(key, modelClass, handle); // ... return viewmodel; }} SavedStateViewModelFactoryAbstractSavedStateViewModelFactory 的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041public final class SavedStateViewModelFactory extends AbstractSavedStateVMFactory { public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner) { this(application, owner, null); } public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs) { mSavedStateRegistry = owner.getSavedStateRegistry(); mLifecycle = owner.getLifecycle(); mDefaultArgs = defaultArgs; mApplication = application; mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); } public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) { constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); } else { constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); } // doesn't need SavedStateHandle if (constructor == null) { return mFactory.create(modelClass); } SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); T viewmodel; if (isAndroidViewModel) { viewmodel = constructor.newInstance(mApplication, controller.getHandle()); } else { viewmodel = constructor.newInstance(controller.getHandle()); } viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; //... }} 它在我们创建 ViewModel 实例的时候被创建: 1MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class); ViewModelProvider 12345678910111213141516171819public class ViewModelProvider { private final Factory mFactory; private final ViewModelStore mViewModelStore; public ViewModelProvider(@NonNull ViewModelStoreOwner owner) { this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance()); } public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { this(owner.getViewModelStore(), factory); } public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { mFactory = factory; mViewModelStore = store; }} ComponentActivity 和 Fragment 都实现了 ViewModelStoreOwner，并返回了一个 SavedStateViewModelFactory。 123456789101112131415161718192021222324252627282930// ComponentActivitypublic ViewModelProvider.Factory getDefaultViewModelProviderFactory() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can't request ViewModel before onCreate call.&quot;); } if (mDefaultFactory == null) { mDefaultFactory = new SavedStateViewModelFactory( getApplication(), this, getIntent() != null ? getIntent().getExtras() : null); } return mDefaultFactory;}// Fragment@NonNull@Overridepublic ViewModelProvider.Factory getDefaultViewModelProviderFactory() { if (mFragmentManager == null) { throw new IllegalStateException(&quot;Can't access ViewModels from detached fragment&quot;); } if (mDefaultFactory == null) { mDefaultFactory = new SavedStateViewModelFactory( requireActivity().getApplication(), this, getArguments()); } return mDefaultFactory;} 而调用 ViewModelProvider 的 get 方法时，若 ViewModelStore 中没有缓存的 ViewModel，就会调用 SavedStateViewModelFactory 实例 mFactory 的 create 方法创建 ViewModel，这一步检查 ViewModel 的构造方法是否有 SavedStateHandle 作为参数，若有就调用构造方法并传入恢复状态的 SavedStateHandle 构造一个 ViewModel。 工作流程 总结本文从 SavedState 引出了 androidx 中 Activity 和 Fragment 保存和恢复状态的流程，并解析了 ViewModel-SavedState 库的工作原理。在 androidx 的支持下现在 Android 开发者可以非常方便的编写不会丢失状态的界面，以前的各种困难都得到了解决。","link":"/2020/06/20/jetpack-savedstate/"},{"title":"Jetpack Lifecycle 原理","text":"Lifecycle 是 Architecture Components 官方架构组件之一。 它可以让我们在另外的组件中感知到 Activity 或 Fragment 的生命周期状态的变化，有助于我们写出更有条理、更精简、易于维护的代码。 引入依赖以下是一份完整的可选依赖方式。 12345678910111213141516171819202122232425262728293031dependencies { def lifecycle_version = &quot;2.2.0&quot; def arch_version = &quot;2.1.0&quot; // ViewModel implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot; // LiveData implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot; // Lifecycles only (without ViewModel or LiveData) implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot; // Saved state module for ViewModel implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot; // Annotation processor kapt &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot; // alternately - if using Java8, use the following instead of lifecycle-compiler implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot; // optional - helpers for implementing LifecycleOwner in a Service implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot; // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot; // optional - ReactiveStreams support for LiveData implementation &quot;androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version&quot; // optional - Test helpers for LiveData testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;} 我们也可以只使用 AppCompat，它已经默认内置了 lifecycle-common 1implementation 'androidx.appcompat:appcompat:1.1.0' 基础使用Java7 中的用法 1234567891011121314151617181920public interface LifecycleObserverIml extends LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.On_CREATE) void onCreate(); @OnLifecycleEvent(Lifecycle.Event.ON_START) void onStart(); @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) void onResume(); @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) void onPause(); @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void onStop(); @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy();} Java8 中的用法 1234567891011121314151617181920212223242526public interface LifecycleObserverIml8 extends DefaultLifecycleObserver { @Override default void onCreate(@NonNull LifecycleOwner owner) { } @Override default void onStart(@NonNull LifecycleOwner owner) { } @Override default void onResume(@NonNull LifecycleOwner owner) { } @Override default void onPause(@NonNull LifecycleOwner owner) { } @Override default void onStop(@NonNull LifecycleOwner owner) { } @Override default void onDestroy(@NonNull LifecycleOwner owner) { }} 在 Activity/Fragment 中使用 1getLifecycle().addObserver(lifecycleObserver); Event &amp; State 源码解析绑定观察者12345678910111213141516171819public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, SavedStateRegistryOwner, OnBackPressedDispatcherOwner { static final class NonConfigurationInstances { Object custom; ViewModelStore viewModelStore; } private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @NonNull @Override public Lifecycle getLifecycle() { return mLifecycleRegistry; }} 调用 getLifecycle() 实际上获取的是 LifecycleRegistry 实例。 LifecycleRegistry 实现了 Lifecycle 接口, 提供了增加/删除观察者的接口 12345678910111213141516public abstract class Lifecycle { @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @NonNull AtomicReference&lt;Object&gt; mInternalScopeRef = new AtomicReference&lt;&gt;(); @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); @MainThread @NonNull public abstract State getCurrentState();} 通知观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LifecycleRegistry extends Lifecycle {//省略相关代码..... public void handleLifecycleEvent(@NonNull Lifecycle.Event event) { State next = getStateAfter(event); moveToState(next); } private void moveToState(State next) { if (mState == next) { return; } mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) { mNewEventOccurred = true; // we will figure out what to do on upper level. return; } mHandlingEvent = true; sync(); mHandlingEvent = false; } // happens only on the top of stack (never in reentrance), // so it doesn't have to take in account parents private void sync() { LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) { throw new IllegalStateException(&quot;LifecycleOwner of this LifecycleRegistry is already&quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot;); } while (!isSynced()) { mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) { backwardPass(lifecycleOwner); } Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) { forwardPass(lifecycleOwner); } } mNewEventOccurred = false; } //省略相关代码.....} 所有的观察者所接受的事件都是由 handleLifecycleEvent() 函数来驱动, 最后分发到 forwardPass 和 backwardPass 这两个函数来进行分发和同步的操作。 forwardPass 遍历观察者集合，当观察者生命周期状态小于当前生命周期状态时分发事件 123456789101112131415private void forwardPass(LifecycleOwner lifecycleOwner) { Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) { Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) { pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); } }} backwardPass 遍历观察者集合，当观察者生命周期状态大于当前生命周期状态时分发事件 123456789101112131415private void backwardPass(LifecycleOwner lifecycleOwner) { Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) { Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) { Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); } }} 感知与分发生命周期Fragment 的生命周期与添加到的 Parent 是同步的，Lifecycle 组件使用了一个 ReportFragment 来感知 Parent 的生命周期，并分发下去： 1234567891011public class ComponentActivity extends Activity implements LifecycleOwner, KeyEventDispatcher.Component { @SuppressLint(&quot;RestrictedApi&quot;) @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); }} ReportFragment 的源码非常清晰，直接看就 Vans 了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class ReportFragment extends Fragment { private static final String REPORT_FRAGMENT_TAG = &quot;androidx.lifecycle&quot; + &quot;.LifecycleDispatcher.report_fragment_tag&quot;; public static void injectIfNeededIn(Activity activity) { if (Build.VERSION.SDK_INT &gt;= 29) { // On API 29+, we can register for the correct Lifecycle callbacks directly activity.registerActivityLifecycleCallbacks( new LifecycleCallbacks()); } // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don't extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) { manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); } } @SuppressWarnings(&quot;deprecation&quot;) static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) { if (activity instanceof LifecycleRegistryOwner) { ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; } if (activity instanceof LifecycleOwner) { Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) { ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); } } } static ReportFragment get(Activity activity) { return (ReportFragment) activity.getFragmentManager().findFragmentByTag( REPORT_FRAGMENT_TAG); } private ActivityInitializationListener mProcessListener; private void dispatchCreate(ActivityInitializationListener listener) { if (listener != null) { listener.onCreate(); } } private void dispatchStart(ActivityInitializationListener listener) { if (listener != null) { listener.onStart(); } } private void dispatchResume(ActivityInitializationListener listener) { if (listener != null) { listener.onResume(); } } @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); } @Override public void onStart() { super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); } @Override public void onResume() { super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); } @Override public void onPause() { super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); } @Override public void onStop() { super.onStop(); dispatch(Lifecycle.Event.ON_STOP); } @Override public void onDestroy() { super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; } private void dispatch(@NonNull Lifecycle.Event event) { if (Build.VERSION.SDK_INT &lt; 29) { // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(getActivity(), event); } }} 如果 SDK &lt; 29 时通过 ReportFragment 进行分发，如果 SDK &gt;= 29 就通过在 Activity 中注册 ReportFragment.LifecycleCallbacks 来分发事件。 123456public void registerActivityLifecycleCallbacks( @NonNull Application.ActivityLifecycleCallbacks callback) { synchronized (mActivityLifecycleCallbacks) { mActivityLifecycleCallbacks.add(callback); }}","link":"/2020/06/16/jetpack-lifecycle/"},{"title":"Jetpack LiveData 原理","text":"根据官方文档的描述，LiveData 是一种可观察的数据存储器类。它具有生命周期感知能力，会遵循 LifeCycleOwner 的生命周期，只有观察者的生命周期处于 STARTED 或 RESUMED 状态的时候才会通知观察者更新。 根据 LiveData 的这一系列特性，将它和 ViewModel 一起使用是在 Android 平台上实现 MVVM 模式的绝佳途径。 使用 LiveData添加依赖1234// LiveDataimplementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot;// LiveData-ktximplementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot; 创建 LiveData123456789class NameViewModel : ViewModel() { // Create a LiveData with a String val currentName: MutableLiveData&lt;String&gt; by lazy { MutableLiveData&lt;String&gt;() } // Rest of the ViewModel...} 避免在 Activity 或 Fragment 中创建 LiveData，正确的做法是使用 ViewModel 管理它。这样会使得代码职责区分更合理，并使得 LiveData 对象在配置更改后依然存在。 观察 LiveData在 Activity 的 onCreate() 或 Fragment 的 onViewCreated() , onActivityCreated() 方法中开始观察其数据变更： 12345678910111213141516171819class NameActivity : AppCompatActivity() { private val model: NameViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Other code to setup the activity... // Create the observer which updates the UI. val nameObserver = Observer&lt;String&gt; { newName -&gt; // Update the UI, in this case, a TextView. nameTextView.text = newName } // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.currentName.observe(this, nameObserver) }} 更新 LiveDataLiveData 不提供更新自身的方法，如果需要更新 LiveData 则应该使用 MutableLiveData 代替。 MutableLiveData 提供了 setValue(T) 和 postValue(T) 来更新 LiveData。 1234button.setOnClickListener { val anotherName = &quot;John Doe&quot; model.currentName.setValue(anotherName)} 主线程更新 LiveData 使用 setValue(T) 方法；Worker 线程更新 LiveData 使用 postValue(T) 方法。 其它 LiveData 用法扩展 LiveData如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 类提供了 onActive() 和 onInactive() 方法来通知子类当前是否有活跃的观察者。 123456789101112131415class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() { private val stockManager = StockManager(symbol) private val listener = { price: BigDecimal -&gt; value = price } override fun onActive() { stockManager.requestPriceUpdates(listener) } override fun onInactive() { stockManager.removeUpdates(listener) }} 我们也可以通过使用一个单例的 LiveData 在不同组件间共享数据： 12345678910111213141516171819202122232425class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() { private val stockManager: StockManager = StockManager(symbol) private val listener = { price: BigDecimal -&gt; value = price } override fun onActive() { stockManager.requestPriceUpdates(listener) } override fun onInactive() { stockManager.removeUpdates(listener) } companion object { private lateinit var sInstance: StockLiveData @MainThread fun get(symbol: String): StockLiveData { sInstance = if (::sInstance.isInitialized) sInstance else StockLiveData(symbol) return sInstance } }} 转换 LiveDataTransformations 类提供了一些方法来转换 LiveData 的值，类似于 RxJava 的各个操作符。 如果需要自定义转换，需要使用 MediatorLiveData，它可以监听其它 LiveData 对象并处理它们的数据。 合并 LiveDataMediatorLiveData 也可以用于合并多个 LiveData，当任意一个 LiveData 数据源变化的时候，MediatorLiveData 都会收到更新。 1234567891011val liveData1: LiveData&lt;Int&gt; = ...val liveData2: LiveData&lt;Int&gt; = ...val result = MediatorLiveData&lt;Int&gt;()result.addSource(liveData1) { value -&gt; result.setValue(value)}result.addSource(liveData2) { value -&gt; result.setValue(value)} 源码分析 我们知道 LiveData 是可以感知生命周期的可被观察的数据存储器类，那么它是如何实现这些特性的呢？我们通过源码来分析一下。 LiveData 库主要由以下三个类构成： LiveData：最核心的类 MutableLiveData：暴露 LiveData 的 setValue 和 postValue 方法 Observer：观察者，提供 onChanged() 方法监听数据变更 LiveDataLiveData 就是我们可以在给定生命周期内观察到的数据存储类。通常我们会同时传入 LifecyclerOwner 和 Observer 来完成数据监听，只有在 LifecycleOwner 处于活动状态的时候，才会通知 Observer 数据变更。 我们看看它的 observe 方法： 123456789101112131415161718192021222324252627282930@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper);}class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } // ...} 当调用 observe 方法时，内部是使用 LifecycleBoundObserver 实例来对 LifecycleOwner 的生命周期进行监听，因此当生命周期变化时会调用 LifecycleBoundObserver 的 onStateChanged 方法： 123456789@Overridepublic void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (mOwner.getLifecycle().getCurrentState() == DESTROYED) { removeObserver(mObserver); return; } activeStateChanged(shouldBeActive());} 当 LifecycleOwner 的生命周期处于 DESTROYED 时，会调用 removeObserver 解除监听。 123456789101112131415161718192021222324@Overrideboolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);}void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) { onActive(); } if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) { onInactive(); } if (mActive) { dispatchingValue(this); }} 此处首先根据生命周期的变化判断目前是活动状态还是非活动状态，并调用对应的 onActive() 或 onInactive() 方法通知子类。最后如果处于活动状态，调用 LiveData 的 dispatchingValue 方法： 1234567891011121314151617181920212223void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false;} 此处显然是进入了 initiator != null 情况的判断分支，然后调用了 considerNotify(initator) 方法： 1234567891011121314private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);} 该方法内部判断了 observer 的状态以及版本号，来决定是否将数据变更通知给 mObserver。 当我们调用 setValue(T) 方法时： 1234567@MainThreadprotected void setValue(T value) { assertMainThread(&quot;setValue&quot;); mVersion++; mData = value; dispatchingValue(null);} mVersion 会自增，然后 value 赋值给 mData，最后调用 dispatchingValue 方法。此处传入的 initiator 为 null，因此走了 else 分支： 1234567for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; }} 此处会遍历所有添加的 Observer，并挨个调用 considerNotify 方法，之后再在 considerNotify 中调用 onChanged 进行通知。 总结LiveData 提供了一种非常方便的观测数据变化更新 UI 的模式。使用它的时候我们不需要关心生命周期的变化导致的各种异常，它会自行感知生命周期通知观察者更新数据。其内部依赖于 LifeCycle 来实现，结合 ViewModel 使用时，我们可以非常轻松的写出健壮且低耦合，易维护的代码。","link":"/2020/06/21/jetpack-livedata/"},{"title":"Compose UI 自定义布局实战","text":"工作中碰到有一个需求是类似于 FlexColumn 的排列，但是项目中的 Compose 版本较低没有 Modifier.fillMaxColumnWidth()，于是考虑使用自定义 Layout 实现。 Compose UI 自定义布局实战LayoutCompose UI 中其实和原生 View 系统类似，也可以实现自己的布局。原生 ViewGroup 需要实现 onMeasure，在里面测量每一个子 View，最后确定自身的尺寸。然后实现 onLayout 确定子 View 如何布局。 Compose 中我们使用 Layout 来实现，也是分两步：测量和布局。 123456Layout( modifier = modifier, content = content,) { measurables, constraints -&gt;} 我们需要对每个 measurable 调用 measure 传入对应的约束（Compose 父布局决定约束条件），然后调用 layout 方法决定每个 placeable 如何布局。 以一个自定义的 Column 为例，我们测量完成之后，一个个根据本身的高度向下排列即可。 12345678910111213141516171819@Composablefun CustomColumn( modifier: Modifier = Modifier, content: @Composable () -&gt; Unit) { Layout( modifier = modifier, content = content ) { measurables, constraints -&gt; val placeables = measurables.map { it.measure(constraints) } var yPosition = 0 layout(constraints.maxWidth, constraints.maxHeight) { placeables.map { it.placeRelative(0, yPosition) yPosition += it.height } } }} 一切复杂的布局其实都是对 Layout 的两个步骤的扩展，只要对测量和布局过程熟悉就可以完成不同的布局的编写。 实战需求是有一个 2～9 个子控件的布局，根据子控件的数量实现如下的排列： FlowColumn 搭配使用 Modifier.fillMaxColumnWidth 和 Modifier.weight 将可以很轻松的实现需求的效果。 但由于项目依赖库的版本较低，无法使用 Modifier.fillMaxColumnWidth，且 FlowColumn 本身还被标记为 ExperimentalLayoutApi，于是该方案无法使用。 考虑到项目情况，该需求应该使用自定义 Layout 实现是更稳妥的方案。 需求分析根据上述需求，我们可以发现该布局是一个以列为基本单位的布局。当子控件不足 7 个的时候，有两列；如果在 7 到 9 个之间，则有 3 列。 确定列数之后，可以取余确定第一列的 item 有多少个，如果余数为 0 表示第一列和其他列一样；否则余数为第一列的 item 个数。 每一列的宽度都是相等的，均分布局，但注意要减去分割线的宽度。 第一列如果是余数列，则以余数的数量均分高度（减去分割线宽度）；否则所有列都是按行数均分高度（减去分割线宽度）。 方法定义根据需求，我们有一个圆角的背景，子控件之间有分割线，所以我们添加对应的参数。 12345678910@Composablefun CustomFlexLayout( modifier: Modifier = Modifier, dividerColor: Color = Color.Black, dividerWidth: Dp = 1.dp, shape: Shape = RoundedCornerShape(16.dp), content: @Composable () -&gt; Unit,) { // ...} 分割线支持Modifier 添加背景和 Shape，然后在布局的时候处理即可。 123modifier = modifier .background(color = dividerColor, shape = shape) .clip(shape), 测量和布局预计算在测量和布局之前，我们已经可以根据参数预先完成计算。然后我们就得出了 item 宽度，余数列(如果不能均分的时候的第一列)和普通列的 item 高度，以及每个 item 的位置（用一个 List 保存方便后续使用）。 12345678910111213141516171819202122232425262728293031323334353637383940// 先确定列val columns = columnStrategy(childrenSize)// 根据列算出最大多少行val maxItemsInEachColumn = (childrenSize + columns - 1) / columns// 如果无法完全均分的话，第一列有多少 item// 当可以均分的时候此数为 0val firstColumnItemsIfNotEvenly = childrenSize % maxItemsInEachColumnval dividerWidthPx = dividerWidth.roundToPx()// 判断当不均分的时候，对应 index 的 item 是否在第一列val isInFirstColumnIfNotEvenly: (Int) -&gt; Boolean = { index -&gt; firstColumnItemsIfNotEvenly &gt; 0 &amp;&amp; index &lt; firstColumnItemsIfNotEvenly}// 预计算一下第一列和正常列 item 高度，不要丢循环里计算val normalColumnItemMaxHeight = (constraints.maxHeight - (dividerWidthPx * (maxItemsInEachColumn - 1).coerceAtLeast(0))) / maxItemsInEachColumnval firstColumnItemMaxHeightIfNotEvenly = if (firstColumnItemsIfNotEvenly == 0) 0else (constraints.maxHeight - (dividerWidthPx * (firstColumnItemsIfNotEvenly - 1).coerceAtLeast(0))) / firstColumnItemsIfNotEvenly// 按规则测量宽度，分割线不能是负数val itemMaxWidth = (constraints.maxWidth - (dividerWidthPx * (columns - 1).coerceAtLeast(0))) / columns// 遍历一下算出 Size 和 Positionval positionList = (0 until childrenSize).map { index -&gt; // 按索引计算所在行和列以及摆放的位置 val (rowIndex, columnIndex, itemMaxHeight) = if (isInFirstColumnIfNotEvenly(index)) { Triple(index, 0, firstColumnItemMaxHeightIfNotEvenly) } else { val adjustIndex = index - firstColumnItemsIfNotEvenly val row = if (maxItemsInEachColumn == 1) 0 else adjustIndex % maxItemsInEachColumn val column = adjustIndex / maxItemsInEachColumn + if (firstColumnItemsIfNotEvenly &gt; 0) 1 else 0 Triple(row, column, normalColumnItemMaxHeight) } val positionX = itemMaxWidth * columnIndex + dividerWidthPx * columnIndex val positionY = itemMaxHeight * rowIndex + dividerWidthPx * rowIndex Pair(positionX, positionY)} 测量需要注意的是 constraints 需要调用 copy 方法按索引生成新的约束，宽度所有 item 都是一样的，高度如果不均分情况下第一列和其他列会不一样。 12345678910111213// 测量子控件val placeables = measurables.mapIndexed { index, measureable -&gt; val maxHeight = if (isInFirstColumnIfNotEvenly(index)) firstColumnItemMaxHeightIfNotEvenly else normalColumnItemMaxHeight measureable.measure( constraints.copy( minWidth = 0, maxWidth = itemMaxWidth, minHeight = 0, maxHeight = maxHeight ) )} 布局使用预计算好的 positionList 摆放子控件即可。 1234567// Layout 摆放子控件layout(constraints.maxWidth, constraints.maxHeight) { placeables.mapIndexed { index, placeable -&gt; val (positionX, positionY) = positionList[index] placeable.placeRelative(positionX, positionY) }} To-do以当前需求而言已经够用了，但是该控件还可以更进一步，比如 目前是列排列优先，可以增加行排列优先的支持 可以去掉子控件数量限制支持更多子控件数量 支持布局反向排列 总结 自定义布局的时候应该注意预先计算好一些参数，可以避免在测量和布局的时候在循环中计算，提高性能。 算法对写自定义布局是有帮助的，有空可以多刷一下 LeetCode 的算法题 善用语法糖可以让编码过程变得愉悦","link":"/2024/12/21/compose-ui-custom-layout/"},{"title":"Kotlin CoroutineContext","text":"CoroutineContext 是协程中的一个重要概念，我们可以通过它来调度协程执行、进行异常处理、跟踪协程层级关系以及携带协程作用域信息。本文通过启动协程的源码，尝试分析其数据结构以及传递机制。 Kotlin CoroutineContextWhat is CoroutineContext通常我们启动一个协程，通过 CoroutineScope.launch 来启动，需要传入三个参数，其中第一个参数就是 CoroutineContext。 123456789101112public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine} 通过初步学习协程我们知道，CoroutineContext 是协程运行时的一种上下文环境，提供了一种机制，用来定义协程的行为和执行环境。每个协程都会关联一个 CoroutineContext，这个上下文包含了一组元素，可以用于控制协程的执行。 下面是 CoroutineContext 类的定义，其注释如下 协程的持久上下文。它是 Element 实例的索引集合。索引集合是 Set 和 Map 的混合体。这个集合中的每个 Element 都有一个唯一的 Key。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@SinceKotlin(&quot;1.3&quot;)public interface CoroutineContext { /** * 返回此上下文中具有给定 [key] 的 Element 或 `null`。 */ public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? /** * 从[初始]值开始累加该上下文的条目，并对当前累加器值和该上下文的每个元素从左至右应用[operation]。 */ public fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R /** * 返回包含本上下文 Element 和其他 [context] Element 的上下文。 * 该上下文中与另一上下文中 Key 相同的 Element 将被删除。 */ public operator fun plus(context: CoroutineContext): CoroutineContext = if (context === EmptyCoroutineContext) this else // 快速通道 -- 避免创建 lambda context.fold(this) { acc, element -&gt; val removed = acc.minusKey(element.key) if (removed === EmptyCoroutineContext) element else { // 确保拦截器在上下文中总是最后一个（因此在出现时可以快速获取） val interceptor = removed[ContinuationInterceptor] if (interceptor == null) CombinedContext(removed, element) else { val left = removed.minusKey(ContinuationInterceptor) if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else CombinedContext(CombinedContext(left, element), interceptor) } } } /** * 返回包含此上下文中元素的上下文，但不包含指定 [key] 的元素。 */ public fun minusKey(key: Key&lt;*&gt;): CoroutineContext /** * [CoroutineContext] Element 的密钥。[E]是具有此关键字的 Element 类型。 */ public interface Key&lt;E : Element&gt; /** * [CoroutineContext] 的一个 Element。协程上下文的 Element 本身就是一个单例上下文。 */ public interface Element : CoroutineContext { /** * 该例程上下文元素的密钥。 */ public val key: Key&lt;*&gt; public override operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? = @Suppress(&quot;UNCHECKED_CAST&quot;) if (this.key == key) this as E else null public override fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R = operation(initial, this) public override fun minusKey(key: Key&lt;*&gt;): CoroutineContext = if (this.key == key) EmptyCoroutineContext else this }} 可以看到该接口的定义是非常简单的，它主要定义了本身的数据结构：Element 的索引集合(Set 和 Map 的混合体)，以及该数据结构的一系列操作： get：根据 Key 获取对应的 Element(不存在时返回 null) fold: 累加 CoroutineContext plus: 重载 + 操作符，实现多个 CoroutineContext 的相加操作，在相加的过程中会把重复 [Key] 的 CoroutineContext 移除，并将 ContinuationInterceptor 类型放到最后 minusKey： 从当前上下文中去除含有 key 的 CoroutineContext 并返回自身 Element 接口就是一个很简单的具有 Key 和 CoroutineContext 的类。 EmptyCoroutineContext上述代码中我们可以看到 EmptyCoroutineContext 和 CoroutineContext，这里查看 EmptyCoroutineContext 的源码发现它是一个空实现，结合在 CoroutineContext 以及 launch 方法不难发现，这就是一个空 CoroutineContext，作为一个占位来使用，内部没有任何特殊的定义和作用。 123456789101112@SinceKotlin(&quot;1.3&quot;)public object EmptyCoroutineContext : CoroutineContext, Serializable { private const val serialVersionUID: Long = 0 private fun readResolve(): Any = EmptyCoroutineContext public override fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? = null public override fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R = initial public override fun plus(context: CoroutineContext): CoroutineContext = context public override fun minusKey(key: Key&lt;*&gt;): CoroutineContext = this public override fun hashCode(): Int = 0 public override fun toString(): String = &quot;EmptyCoroutineContext&quot;} CombinedContextCombinedContext 是 CoroutineContext 数据结构的基础，它持有一个 left 指向自身左边的 CoroutineContext，element 则代表自身持有的 CoroutineContext，多个不同的 CombinedContext 相连则组成了一个单向链表结构。 这里注意 size 最小是 2，这是因为只有当有 2 个元素或以上，才会使用到 CombinedContext。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@SinceKotlin(&quot;1.3&quot;)internal class CombinedContext( private val left: CoroutineContext, private val element: Element) : CoroutineContext, Serializable { override fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key&lt;*&gt;): CoroutineContext { element[key]?.let { return left } val newLeft = left.minusKey(key) return when { newLeft === left -&gt; this newLeft === EmptyCoroutineContext -&gt; element else -&gt; CombinedContext(newLeft, element) } } private fun size(): Int { var cur = this var size = 2 while (true) { cur = cur.left as? CombinedContext ?: return size size++ } } private fun contains(element: Element): Boolean = get(element.key) == element private fun containsAll(context: CombinedContext): Boolean { var cur = context while (true) { if (!contains(cur.element)) return false val next = cur.left if (next is CombinedContext) { cur = next } else { return contains(next as Element) } } } override fun equals(other: Any?): Boolean = this === other || other is CombinedContext &amp;&amp; other.size() == size() &amp;&amp; other.containsAll(this) override fun hashCode(): Int = left.hashCode() + element.hashCode() override fun toString(): String = &quot;[&quot; + fold(&quot;&quot;) { acc, element -&gt; if (acc.isEmpty()) element.toString() else &quot;$acc, $element&quot; } + &quot;]&quot; private fun writeReplace(): Any { val n = size() val elements = arrayOfNulls&lt;CoroutineContext&gt;(n) var index = 0 fold(Unit) { _, element -&gt; elements[index++] = element } check(index == n) @Suppress(&quot;UNCHECKED_CAST&quot;) return Serialized(elements as Array&lt;CoroutineContext&gt;) } private class Serialized(val elements: Array&lt;CoroutineContext&gt;) : Serializable { companion object { private const val serialVersionUID: Long = 0L } private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus) }} How CoroutineContext workCoroutineContext 如何传递还是从 launch 方法继续出发，其第一行调用了 newCoroutineContext 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ExperimentalCoroutinesApipublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext { val combined = foldCopies(coroutineContext, context, true) val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null) debug + Dispatchers.Default else debug}private fun foldCopies(originalContext: CoroutineContext, appendContext: CoroutineContext, isNewCoroutine: Boolean): CoroutineContext { // 我们有东西要复制到左手边吗？ val hasElementsLeft = originalContext.hasCopyableElements() val hasElementsRight = appendContext.hasCopyableElements() // 无需折叠，只需返回上下文的总和。 if (!hasElementsLeft &amp;&amp; !hasElementsRight) { return originalContext + appendContext } var leftoverContext = appendContext val folded = originalContext.fold&lt;CoroutineContext&gt;(EmptyCoroutineContext) { result, element -&gt; if (element !is CopyableThreadContextElement&lt;*&gt;) return@fold result + element // 该元素会被覆盖吗？ val newElement = leftoverContext[element.key] // 不，复制即可 if (newElement == null) { // 对于类似于 &quot;withContext &quot;的构建器，我们不会复制，因为元素不是共享的 return@fold result + if (isNewCoroutine) element.copyForChild() else element } // 是，那么首先从追加上下文中移除元素 leftoverContext = leftoverContext.minusKey(element.key) // 返回总和 @Suppress(&quot;UNCHECKED_CAST&quot;) return@fold result + (element as CopyableThreadContextElement&lt;Any?&gt;).mergeForChild(newElement) } if (hasElementsRight) { leftoverContext = leftoverContext.fold&lt;CoroutineContext&gt;(EmptyCoroutineContext) { result, element -&gt; // 我们正在添加新的上下文元素 -- 我们必须复制它，否则它可能会被其他人共享 if (element is CopyableThreadContextElement&lt;*&gt;) { return@fold result + element.copyForChild() } return@fold result + element } } return folded + leftoverContext} 该代码是通过 foldCopies 方法对父协程的 CoroutineContext 和 launch 方法启动传入的 CoroutineContext 进行组合并复制了一份拷贝作为子协程的 CoroutineContext。 这也是协程传递 CoroutineContext 的核心逻辑。 CoroutineContext 如何作用我们以默认参数的 launch 方法为例，默认会创建一个 StandaloneCoroutine 调用其 start 方法，StandaloneCoroutine 是一个 AbstractCoroutine，其持有了上面合并后的 Context。而 AbstractCoroutine 也在 init 块里初始化了 Job 和父子 Job 的关联，这里就不具体展开了。 12345678910@OptIn(InternalForInheritanceCoroutinesApi::class)@InternalCoroutinesApipublic abstract class AbstractCoroutine&lt;in T&gt;( parentContext: CoroutineContext, initParentJob: Boolean, active: Boolean) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope { public final override val context: CoroutineContext = parentContext + this} 我们知道当协程执行时，会通过 Continuation 接口传递这个 CoroutineContext 1234public interface Continuation&lt;in T&gt; { public val context: CoroutineContext public fun resumeWith(result: Result&lt;T&gt;)} 状态机生成的代码会使用这个 CoroutineContext 来: 调度协程执行(通过 Dispatcher) 进行异常处理(通过 CoroutineExceptionHandler) 跟踪协程层级关系(通过 Job) 携带协程作用域信息(通过 CoroutineName 等)","link":"/2024/12/08/kotlin-coroutine-context/"},{"title":"KSP","text":"Kotlin 符号处理（KSP）是一种 API，您可以用它来开发轻量级编译器插件。KSP 提供了一个简化的编译器插件 API，可充分利用 Kotlin 的强大功能，同时将学习曲线保持在最低水平。与 kapt 相比，使用 KSP 的注释处理器运行速度最多可提高两倍。 KSPWhat is KSP借用官网的内容 Kotlin 符号处理（KSP）是一种 API，您可以用它来开发轻量级编译器插件。KSP 提供了一个简化的编译器插件 API，可充分利用 Kotlin 的强大功能，同时将学习曲线保持在最低水平。与 kapt 相比，使用 KSP 的注释处理器运行速度最多可提高两倍。 直白的意思就是说，可以读取 Kotlin 文件中的注释，在编译过程中对注解和其注解的内容进行处理的一个框架。 常见的使用方式如使用注解处理器搭配 KPoet生成模板代码(如 ButterKnife、Room)，或者使用注解处理器搭配 ASM 或 KASM 在编译期进行字节码插桩以实现面向切面编程。 Why KSP简单的说，对比 kapt 而言 KSP 的性能更高，不依赖于 JVM 平台，API 设计以 Kotlin 的语法为目标，更易使用也更加容易理解。 kapt 将 Kotlin 代码编译成 Java 存根，这些存根保留了 Java 注释处理器关心的信息，但也拖慢了速度。生成存根的成本大约是完整 kotlinc 分析的 1/3，这个过程可能比很多注解处理器耗费的时间还长。 Quick Start参照官网教程 创建自定义处理器 创建 Kotlin 项目 在项目中引入 ksp 依赖 123dependencies { implementation(&quot;com.google.devtools.ksp:symbol-processing-api:2.1.0-1.0.29&quot;)} 创建自定义注解 123@Target(AnnotationTarget.CLASS)@Retention(AnnotationRetention.SOURCE)annotation class TestAnnotation 实现 SymbolProcessor 12345678910111213141516171819202122class TestSymbolProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor { /** * 由Kotlin符号处理调用来运行处理任务。 * Params: * 解析器-为SymbolProcessor提供对编译器详细信息的访问权限，例如符号。 * Returns: * 处理器无法处理的延迟符号列表。只应返回本轮无法处理的符号。编译代码（库）中的符号始终有效，如果在延迟列表中返回，则会被忽略。 */ override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; { environment.logger.warn(&quot;TestSymbolProcessor begin process!&quot;) val symbols = resolver.getSymbolsWithAnnotation(TestAnnotation::class.qualifiedName!!) val list = mutableListOf&lt;KSAnnotated&gt;() symbols.forEach { symbol -&gt; if (!symbol.validate()) list.add(symbol) else symbol.accept(TestSymbolVisitor(environment), Unit) } return list }} 实现 SymbolProcessorProvider 12345class TestSymbolProcessorProvider : SymbolProcessorProvider { override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor { return TestSymbolProcessor(environment) }} 实现 KSVisitor 123456789class TestSymbolVisitor(private val environment: SymbolProcessorEnvironment) : KSVisitorVoid() { override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) { // 因为我们定义的注解是一个目标是 CLASS 的所以我们在 visit class 里处理就行 if (classDeclaration.annotations.any { it.annotationType.resolve().declaration.qualifiedName?.asString() == TestAnnotation::class.qualifiedName }) { // 打印出被注解的类的全名 environment.logger.warn(classDeclaration.qualifiedName?.asString() ?: &quot;&quot;) } }} symbol.accept 方法的第一个参数需要传入一个 KSVisitor&lt;D, R&gt;。D 是上下文或数据，R 是返回值。一般情况下如果不需要传递上下文(数据) 以及不需要返回值，使用 KSVisitorVoid 即可。 KSVisitor 提供了 visitX 系列方法，以及一个保底的 visitNode 方法，在里面可以拦截对应扫描到类、注解、方法、参数等，这样就可以进行对应的处理了。 比如利用 KPoet 生成 Kotlin 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475interface KSVisitor&lt;D, R&gt; { fun visitNode(node: KSNode, data: D): R // 处理被注解标注的元素 fun visitAnnotated(annotated: KSAnnotated, data: D): R // 处理注解本身 fun visitAnnotation(annotation: KSAnnotation, data: D): R // 处理修饰符的拥有者 fun visitModifierListOwner(modifierListOwner: KSModifierListOwner, data: D): R // 处理声明?? fun visitDeclaration(declaration: KSDeclaration, data: D): R // 处理声明容器?? fun visitDeclarationContainer(declarationContainer: KSDeclarationContainer, data: D): R // 处理动态引用?? fun visitDynamicReference(reference: KSDynamicReference, data: D): R // 处理一个 Kotlin 文件 fun visitFile(file: KSFile, data: D): R // 处理函数声明（KSFunctionDeclaration），包括普通函数和扩展函数。 fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: D): R // 处理函数引用 fun visitCallableReference(reference: KSCallableReference, data: D): R // 处理括号内的引用(lambda 里的 it 或其它命名的引用) fun visitParenthesizedReference(reference: KSParenthesizedReference, data: D): R // 处理属性声明 fun visitPropertyDeclaration(property: KSPropertyDeclaration, data: D): R // 处理属性的 setter getter fun visitPropertyAccessor(accessor: KSPropertyAccessor, data: D): R // 处理属性的 getter fun visitPropertyGetter(getter: KSPropertyGetter, data: D): R // 处理属性的 setter fun visitPropertySetter(setter: KSPropertySetter, data: D): R // 处理引用元素 fun visitReferenceElement(element: KSReferenceElement, data: D): R // 处理类型别名 fun visitTypeAlias(typeAlias: KSTypeAlias, data: D): R // 处理类型参数 fun visitTypeArgument(typeArgument: KSTypeArgument, data: D): R // 处理类声明 fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: D): R // 处理类型参数，例如泛型类型中的 T。 fun visitTypeParameter(typeParameter: KSTypeParameter, data: D): R // 处理类型引用，例如函数或属性的类型。 fun visitTypeReference(typeReference: KSTypeReference, data: D): R // 处理注解或函数调用的参数（KSValueArgument）。 fun visitValueParameter(valueParameter: KSValueParameter, data: D): R // 处理函数或构造函数的参数声明（KSValueParameter）。 fun visitValueArgument(valueArgument: KSValueArgument, data: D): R // 处理类、接口和对象的引用 fun visitClassifierReference(reference: KSClassifierReference, data: D): R // 处理非空引用 fun visitDefNonNullReference(reference: KSDefNonNullReference, data: D): R}","link":"/2024/12/01/kotlin-symbol-processing/"}],"tags":[{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"github-pages","slug":"github-pages","link":"/tags/github-pages/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Volley","slug":"Volley","link":"/tags/Volley/"},{"name":"RIME","slug":"RIME","link":"/tags/RIME/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"友盟","slug":"友盟","link":"/tags/%E5%8F%8B%E7%9B%9F/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"LEDE","slug":"LEDE","link":"/tags/LEDE/"},{"name":"GFW","slug":"GFW","link":"/tags/GFW/"},{"name":"react native","slug":"react-native","link":"/tags/react-native/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"Scala","slug":"Scala","link":"/tags/Scala/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Apple","slug":"Apple","link":"/tags/Apple/"},{"name":"健身","slug":"健身","link":"/tags/%E5%81%A5%E8%BA%AB/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"玩具","slug":"玩具","link":"/categories/%E7%8E%A9%E5%85%B7/"},{"name":"健身","slug":"健身","link":"/categories/%E5%81%A5%E8%BA%AB/"}],"pages":[{"title":"","text":"","link":"/tags/index.html"},{"title":"","text":"关于我就是个 Android 从业者，喜欢研究新技术，喜欢一些好玩儿的东西 联系方式 @loshine loshine1992@gmail.com","link":"/about/index.html"}]}